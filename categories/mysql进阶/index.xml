<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>MySQL进阶 on JIAYI&#39;s Blog</title>
    <link>https://jiayi26.github.io/categories/mysql%E8%BF%9B%E9%98%B6/</link>
    <description>Recent content in MySQL进阶 on JIAYI&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://jiayi26.github.io/categories/mysql%E8%BF%9B%E9%98%B6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>InnoDB数据存储结构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>第07章 InnoDB数据存储结构 1. 数据库的存储结构：页 索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。
由于InnoDB是MySQL的默认存储引擎，所以本章剖析InooDB存储引擎的数据存储结构。
1.1 磁盘与内存交互基本单位：页 InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16KB。
以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。
 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。
 1.2 页结构概述 页a、页b、页c&amp;hellip;页n这些页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。
1.3 页的上层结构 区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。
段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。
表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。
2. 页的内部结构 2.1 第1部分：文件头部和文件尾部 2.1.1 File Header（文件头部）（38字节） 作用： 描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）
大小：38字节
   名称 占用空间大小 描述     FIL_PAGE_SPACE_OR_CHKSUM 4字节 页的校验和（checksum值）   FIL_PAGE_OFFSET 4字节 页号   FIL_PAGE_PREV 4字节 上一个页的页号   FIL_PAGE_NEXT 4字节 下一个页的页号   FIL_PAGE_LSN 8字节 页面被最后修改时对应的日志序列位置   FIL_PAGE_TYPE 2字节 该页的类型   FIL_PAGE_FILE_FLUSH_LSN 8字节 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值   FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID 4字节 页属于哪个表空间     FIL_PAGE_OFFSET（4字节）：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。 FIL_PAGE_TYPE（2字节）：这个代表当前页的类型。     类型名称 十六进制 描述     FIL_PAGE_TYPE_ALLOCATED 0x0000 最新分配，还没有使用   FIL_PAGE_UNDO_LOG 0x0002 Undo日志页   FIL_PAGE_INODE 0x0003 段信息节点   FIL_PAGE_IBUF_FREE_LIST 0x0004 Insert Buffer空闲列表   FIL_PAGE_IBUF_BITMAP 0x0005 Insert Buffer位图   FIL_PAGE_TYPE_SYS 0x0006 系统页   FIL_PAGE_TYPE_TRX_SYS 0x0007 事务系统数据   FIL_PAGE_TYPE_FSP_HDR 0x0008 表空间头部信息   FIL_PAGE_TYPE_XDES 0x0009 扩展描述页   FIL_PAGE_TYPE_BLOB 0x000A 溢出页   FIL_PAGE_INDEX 0x45BF 索引页，也就是我们所说的数据页     FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。 FIL_PAGE_SPACE_OR_CHKSUM（4字节）：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM  作用：</description>
    </item>
    
    <item>
      <title>Linux下MySQL的安装与使用</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0-linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0-linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>第01章 Linux下MySQL的安装与使用 1. 安装前说明 1.1 查看是否安装过MySQL  如果你是用rpm安装, 检查一下RPM PACKAGE：  rpm -qa | grep -i mysql # -i 忽略大小写  检查mysql service：  systemctl status mysqld.service 1.2 MySQL的卸载 1. 关闭 mysql 服务
systemctl stop mysqld.service 2. 查看当前 mysql 安装状况
rpm -qa | grep -i mysql # 或 yum list installed | grep mysql 3. 卸载上述命令查询出的已安装程序
yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx 务必卸载干净，反复执行rpm -qa | grep -i mysql确认是否有卸载残留
4. 删除 mysql 相关文件</description>
    </item>
    
    <item>
      <title>MySQL事务日志</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</guid>
      <description>第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？
 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。
1.2 REDO日志的好处、特点 1. 好处
 redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点
 redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：
 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：
redo log buffer 大小，默认16M，最大值是4096M，最小值为1M。
 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</description>
    </item>
    
    <item>
      <title>MySQL的数据目录</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</guid>
      <description>第02章 MySQL的数据目录 1. MySQL8的主要目录结构 find / -name mysql 1.1 数据库文件的存放路径 show variables like &amp;#39;datadir&amp;#39;; # /var/lib/mysql/ 1.2 相关命令目录 相关命令目录：/usr/bin 和/usr/sbin。
1.3 配置文件目录 配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）
2. 数据库和文件系统的关系 2.1 表在文件系统中的表示 2.3.1 InnoDB存储引擎模式 1. 表结构
为了保存表结构，InnoDB在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件
表名.frm 2. 表中数据和索引
① 系统表空间（system tablespace）
默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的自拓展文件，这个文件就是对应的系统表空间在文件系统上的表示。
② 独立表空间(file-per-table tablespace)
在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。
表名.ibd  MySQL8.0中不再单独提供表名.frm，而是合并在表名.ibd文件中。
 ③ 系统表空间与独立表空间的设置
我们可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动参数innodb_file_per_table控制
[server]  innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间 ④ 其他类型的表空间
随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。
2.3.2 MyISAM存储引擎模式 1. 表结构
在存储表结构方面， MyISAM 和 InnoDB 一样，也是在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件</description>
    </item>
    
    <item>
      <title>主从复制</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>第18章 主从复制 1. 主从复制概述 1.1 如何提升数据库并发能力 一般应用对数据库而言都是“读多写少”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做主从架构、进行读写分离，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。
如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化SQL和索引，这种方式简单有效；其次才是采用缓存的策略，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用主从架构，进行读写分离。
1.2 主从复制的作用 第1个作用：读写分离。
第2个作用就是数据备份。
第3个作用是具有高可用性。
2. 主从复制的原理 2.1 原理剖析 三个线程
实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于3 个线程来操作，一个主库线程，两个从库线程。
二进制日志转储线程（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。
从库 I/O 线程会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。
从库 SQL 线程会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。
复制三步骤
步骤1：Master将写操作记录到二进制日志（binlog）。
步骤2：Slave将Master的binary log events拷贝到它的中继日志（relay log）；
步骤3：Slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。
复制的问题
复制的最大问题：延时
2.2 复制的基本原则   每个Slave只有一个Master
  每个Slave只能有一个唯一的服务器ID
  每个Master可以有多个Slave
  3. 同步数据一致性问题 主从同步的要求：
  读库和写库的数据一致(最终一致)；</description>
    </item>
    
    <item>
      <title>事务基础知识</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>第13章 事务基础知识 1. 数据库事务概述 1.1 基本概念 **事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。
**事务处理的原则：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。
1.2 事务的ACID特性  原子性（atomicity）：  原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。
 一致性（consistency）：  一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。
 隔离型（isolation）：  事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
 持久性（durability）：  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。
1.3 事务的状态  活动的（active）  事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。
 部分提交的（partially committed）  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。
 失败的（failed）  当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。
 中止的（aborted）  如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。
 提交的（committed）  当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。
2. 如何使用事务 2.1 显式事务 步骤1： START TRANSACTION或者BEGIN，作用是显式开启一个事务。
mysql&amp;gt; BEGIN; #或者 mysql&amp;gt; START TRANSACTION; START TRANSACTION语句相较于BEGIN特别之处在于，后边能跟随几个修饰符：
①READ ONLY：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。
②READ WRITE：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。
③WITH CONSISTENT SNAPSHOT：启动一致性读。</description>
    </item>
    
    <item>
      <title>其它数据库日志</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0-%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0-%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</guid>
      <description>第17章 其它数据库日志 1. MySQL支持的日志 1.1 日志类型 MySQL有不同类型的日志文件，用来存储不同类型的日志，分为二进制日志、错误日志、通用查询日志和慢查询日志，这也是常用的4种。MySQL 8又新增两种支持的日志：中继日志和数据定义语句日志。使用这些日志文件，可以查看MySQL内部发生的事情。
  **慢查询日志：**记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。
  **通用查询日志：**记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
  **错误日志：**记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。
  **二进制日志：**记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
  **中继日志：**用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
  **数据定义语句日志：**记录数据定义语句执行的元数据操作。
  除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。
1.2 日志的弊端   日志功能会降低MySQL数据库的性能。
  日志会占用大量的磁盘空间。
  2. 通用查询日志(general query log) 通用查询日志用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。
2.1 查看当前状态 mysql&amp;gt; SHOW VARIABLES LIKE &amp;#39;%general%&amp;#39;; 2.2 启动日志 方式1：永久性方式
[mysqld]  general_log=ON  general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名 方式2：临时性方式
SET GLOBAL general_log=on; # 开启通用查询日志 SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置 SET GLOBAL general_log=off; # 关闭通用查询日志 SHOW VARIABLES LIKE &amp;#39;general_log%&amp;#39;; # 查看设置后情况 2.</description>
    </item>
    
    <item>
      <title>多版本并发控制</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>第16章 多版本并发控制 1. 什么是MVCC MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。
2. 快照读与当前读 MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读，而这个读指的就是快照读, 而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。
2.1 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读。
之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。
既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。
快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。
2.2 当前读 当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。
3. 复习 3.1 再谈隔离级别 我们知道事务有 4 个隔离级别，可能存在三种并发问题：
另图：
3.2 隐藏字段、Undo Log版本链 回顾一下undo日志的版本链，对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。
 trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id 隐藏列。 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。  4. MVCC实现原理之ReadView MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。
4.1 什么是ReadView ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID（“活跃”指的就是，启动了但还没提交）。
4.2 设计思路 使用READ UNCOMMITTED隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。
使用SERIALIZABLE隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。
使用READ COMMITTED和REPEATABLE READ隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。
这个ReadView中主要包含4个比较重要的内容，分别如下：
 creator_trx_id，创建这个 Read View 的事务 ID。   说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</description>
    </item>
    
    <item>
      <title>存储引擎</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>第05章 存储引擎 1. 查看存储引擎 show engines; # 或 show engines\G 2. 设置系统默认的存储引擎  查看默认的存储引擎：  show variables like &amp;#39;%storage_engine%&amp;#39;; #或 SELECT @@default_storage_engine;  修改默认的存储引擎  如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用InnoDB作为表的存储引擎。
SET DEFAULT_STORAGE_ENGINE=MyISAM; 或者修改my.cnf文件：
default-storage-engine=MyISAM  # 重启服务  systemctl restart mysqld.service 3. 设置表的存储引擎 存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。
3.1 创建表时指定存储引擎 CREATE TABLE 表名(  建表语句; ) ENGINE = 存储引擎名称; 3.2 修改表的存储引擎 ALTER TABLE 表名 ENGINE = 存储引擎名称; 4. 引擎介绍 4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎  MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，默认采用InnoDB引擎。 InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 数据文件结构：  表名.</description>
    </item>
    
    <item>
      <title>性能分析工具的使用</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>第09章 性能分析工具的使用 1. 统计SQL的查询成本：last_query_cost SHOW STATUS LIKE &amp;#39;last_query_cost&amp;#39;; 使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。
 SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
 位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。  所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。
 2. 定位执行慢的SQL：慢查询日志 MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。
默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。
2.1 开启慢查询日志参数 1. 开启slow_query_log
set global slow_query_log=&amp;#39;ON&amp;#39;; 查看下慢查询日志是否开启，以及慢查询日志文件的位置：
show variables like `%slow_query_log%`; 2. 修改long_query_time阈值
show variables like &amp;#39;%long_query_time%&amp;#39;; #测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 mysql &amp;gt; set global long_query_time = 1; mysql&amp;gt; show global variables like &amp;#39;%long_query_time%&amp;#39;;  mysql&amp;gt; set long_query_time=1; mysql&amp;gt; show variables like &amp;#39;%long_query_time%&amp;#39;; 2.2 查看慢查询数目 SHOW GLOBAL STATUS LIKE &amp;#39;%Slow_queries%&amp;#39;; 2.</description>
    </item>
    
    <item>
      <title>数据库其它调优策略</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</guid>
      <description>第12章 数据库其它调优策略 1. 数据库调优的措施 1.1 调优的目标  尽可能节省系统资源，以便系统可以提供更大负荷的服务。（吞吐量更大） 合理的结构设计和参数调整，以提高用户操 响应的速度。（响应速度更快） 减少系统的瓶颈，提高MySQL数据库整体的性能。  1.2 如何定位调优问题  用户的反馈（主要） 日志分析（主要） 服务器资源使用监控 数据库内部状况监控 其它  1.3 调优的维度和步骤 第1步：选择适合的 DBMS
第2步：优化表设计
第3步：优化逻辑查询
第4步：优化物理查询
物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。
第5步：使用 Redis 或 Memcached 作为缓存
第6步：库级优化
1、读写分离
2、数据分片
2. 优化MySQL服务器 2.1 优化服务器硬件 **服务器的硬件性能直接决定着MySQL数据库的性能。**硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。
（1）配置较大的内存
（2）配置高速磁盘系统
（3）合理分布磁盘I/O
（4）配置多处理器
2.2 优化MySQL的参数  innodb_buffer_pool_size：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存表的数据。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。 key_buffer_size：表示索引缓冲区的大小。索引缓冲区是所有的线程共享。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。 table_cache：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。 query_cache_size：表示查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。 query_cache_type的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。  当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定SQL_NO_CACHE，如SELECT SQL_NO_CACHE * FROM tbl_name。 当query_cache_type=2时，只有在查询语句中使用SQL_CACHE关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。   sort_buffer_size：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高ORDER BY或GROUP BY操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 join_buffer_size = 8M：表示联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。 read_buffer_size：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。 innodb_flush_log_at_trx_commit：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。  值为0时，表示每秒1次的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。 值为1时，表示每次提交事务时将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。 值为2时，表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。   innodb_log_buffer_size：这是 InnoDB 存储引擎的事务日志所使用的缓冲区。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。 max_connections：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。 back_log：用于控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.</description>
    </item>
    
    <item>
      <title>数据库备份与恢复</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC19%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC19%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid>
      <description>第19章 数据库备份与恢复 1. 物理备份与逻辑备份 物理备份：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用xtrabackup工具来进行物理备份。
逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为mysqldump。逻辑备份就是备份sql语句，在恢复的时候执行备份的sql语句实现数据库数据的重现。
2. mysqldump实现逻辑备份 2.1 备份一个数据库 mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&amp;gt; 备份文件名 称.sql mysqldump -uroot -p atguigu&amp;gt;atguigu.sql #备份文件存储在当前目录下 mysqldump -uroot -p atguigudb1 &amp;gt; /var/lib/mysql/atguigu.sql 2.2 备份全部数据库 mysqldump -uroot -pxxxxxx --all-databases &amp;gt; all_database.sql mysqldump -uroot -pxxxxxx -A &amp;gt; all_database.sql 2.3 备份部分数据库 mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &amp;gt; 备份文件名 称.sql mysqldump -uroot -p --databases atguigu atguigu12 &amp;gt;two_database.sql mysqldump -uroot -p -B atguigu atguigu12 &amp;gt; two_database.</description>
    </item>
    
    <item>
      <title>数据库的设计规范</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
1.3 键和相关属性的概念 这里有两个表：
球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team)：球队编号 | 主教练 | 球队所在地
 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。
1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&amp;quot;A&amp;ndash;&amp;gt;B&amp;ndash;&amp;gt;C&amp;quot;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。
1.7 小结 关于数据表的设计，有三个范式要遵循。
（1）第一范式（1NF），确保每列保持原子性
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
（2）第二范式（2NF），确保每列都和主键完全依赖
尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。
（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关
**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。
范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。
2. 反范式化 2.1 概述 规范化 vs 性能
  为满足某种商业目标 , 数据库性能比规范化数据库更重要</description>
    </item>
    
    <item>
      <title>用户与权限管理</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>第03章 用户与权限管理 1. 用户管理 1.1 登录MySQL服务器 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：
mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &amp;#34;SQL语句&amp;#34;  -h参数后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 -P参数后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。 -u参数后面接用户名，username为用户名。 -p参数会提示输入密码。 DatabaseName参数指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。 -e参数后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。  mysql -uroot -p -hlocalhost -P3306 mysql -e &amp;#34;select host,user from user&amp;#34; 1.2 创建用户 CREATE USER 用户名 [IDENTIFIED BY &amp;#39;密码&amp;#39;][,用户名 [IDENTIFIED BY &amp;#39;密码&amp;#39;]]; 举例：
CREATE USER zhang3 IDENTIFIED BY &amp;#39;123123&amp;#39;; # 默认host是 % CREATE USER &amp;#39;kangshifu&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;123456&amp;#39;; 1.3 修改用户 UPDATE mysql.user SET USER=&amp;#39;li4&amp;#39; WHERE USER=&amp;#39;wang5&amp;#39;; FLUSH PRIVILEGES; 1.</description>
    </item>
    
    <item>
      <title>索引优化与查询优化</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。
 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。
1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。
1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）
 1.7 不等于(!= 或者&amp;lt;&amp;gt;)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&amp;rsquo;&#39;)
拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描
 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。
1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。
2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现
结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表
结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表
 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。</description>
    </item>
    
    <item>
      <title>索引的创建与设计原则</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>第08章 索引的创建与设计原则 1. 索引的声明与使用 1.1 索引的分类  从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数进行划分，分成单列索引和联合索引。  1.2 创建索引 CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]  UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引； INDEX与KEY为同义词，两者的作用相同，用来指定创建索引； index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； ASC或DESC指定升序或者降序的索引值存储。  1. 创建普通索引
CREATE TABLE book(  book_id INT ,  book_name VARCHAR(100),  authors VARCHAR(100),  info VARCHAR(100) ,  comment VARCHAR(100),  year_publication YEAR,  INDEX(year_publication) ); 2.</description>
    </item>
    
    <item>
      <title>索引的数据结构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>第06章 索引的数据结构 1. 索引及其优缺点 1.1 索引概述 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。
1.2 优点 （1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因。
（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。
1.3 缺点 （1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
（3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
2. InnoDB中索引的推演 2.1 索引之前的查找 SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 1.在一个页中的查找
假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
 以主键为搜索条件  可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。   以其他列作为搜索条件  因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。    2.在很多页中查找
大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：
 定位到记录所在的页。 从所在的页内查找相应的记录。  在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。
2.2 设计索引 mysql&amp;gt; CREATE TABLE index_demo(  -&amp;gt; c1 INT,  -&amp;gt; c2 INT,  -&amp;gt; c3 CHAR(1),  -&amp;gt; PRIMARY KEY(c1)  -&amp;gt; ) ROW_FORMAT = Compact; 这个新建的index_demo表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</description>
    </item>
    
    <item>
      <title>逻辑架构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid>
      <description>第04章 逻辑架构 1. 逻辑架构剖析 1.1 第1层：连接层 系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。
经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。
 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限  TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。
1.2 第2层：服务层   SQL Interface: SQL接口
 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT &amp;hellip; FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口    Parser: 解析器
 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。    Optimizer: 查询优化器
 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用“选取-投影-连接”策略进行查询。例如：  SELECT id,name FROM student WHERE gender = &amp;#39;女&amp;#39;; 这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。
  Caches &amp;amp; Buffers： 查询缓存组件
 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享。 从MySQL 5.</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0-%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0-%E9%94%81/</guid>
      <description>第15章 锁 1. 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2. MySQL并发事务访问相同记录 2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。
2.3 读-写或写-读情况 读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。
2.4 并发问题的解决方案 怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：
 方案一：读操作利用多版本并发控制（MVCC，下章讲解），写操作进行加锁。  所谓的MVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本（历史版本由undo日志构建）。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。
 普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。
 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象； 在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都复用这ReadView，这样也就避免了不可重复读和幻读的问题。     方案二：读、写操作都采用加锁的方式。
  小结对比发现：
 采用MVCC方式的话，读-写操作彼此并不冲突，性能更高。 采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。    一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。
3. 锁的不同角度分类 3.1 从数据操作的类型划分：读锁、写锁  读锁：也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。 写锁：也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。
1. 锁定读
在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式：
 对读取的记录加S锁：  SELECT ... LOCK IN SHARE MODE; # 或 SELECT .</description>
    </item>
    
  </channel>
</rss>
