<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on JIAYI&#39;s Blog</title>
    <link>https://jiayi26.github.io/posts/</link>
    <description>Recent content in Posts on JIAYI&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Dec 2022 15:29:33 +0800</lastBuildDate><atom:link href="https://jiayi26.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL8其它新特性</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0_mysql8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0_mysql8%E5%85%B6%E5%AE%83%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>1. MySQL8新特性概述 MySQL从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。
1.1 MySQL8.0 新增特性 1. 更简便的NoSQL支持 NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。
2. 更好的索引 在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了隐藏索引和降序索引。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。
3.更完善的JSON支持 MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数JSON_ARRAYAGG()和JSON_OBJECTAGG()，将参数聚合为JSON数组或对象，新增了行内操作符 -&amp;raquo;，是列路径运算符 -&amp;gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。
4.安全和账户管理 MySQL 8中新增了caching_sha2_password 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。
5.InnoDB的变化 InnoDB是MySQL默认的存储引擎，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。
6.数据字典 在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。
7. 原子数据定义语句 MySQL 8开始支持原子数据定义语句（Automic DDL），即原子DDL。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。 使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加IF EXISTS或IF NOT EXISTS语句来避免发生错误。
8.资源管理 MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。 目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。
9.字符集支持 MySQL 8中默认的字符集由latin1更改为utf8mb4，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。
10.优化器增强 MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。
11.公用表表达式 公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前使用WITH语句对临时结果集进行命名。
基础语法如下：
WITH cte_name (col_name1,col_name2 .</description>
    </item>
    
    <item>
      <title>MySQL数据类型精讲</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0_mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0_mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/</guid>
      <description>第12章_MySQL数据类型精讲 1. MySQL中的数据类型    类型 类型举例     整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT   浮点类型 FLOAT、DOUBLE   定点数类型 DECIMAL   位类型 BIT   日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP   文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT   枚举类型 ENUM   集合类型 SET   二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB   JSON类型 JSON对象、JSON数组   空间数据类型 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION    常见数据类型的属性，如下：
   MySQL关键字 含义     NULL 数据列可包含NULL值   NOT NULL 数据列不允许包含NULL值   DEFAULT 默认值   PRIMARY KEY 主键   AUTO_INCREMENT 自动递增，适用于整数类型   UNSIGNED 无符号   CHARACTER SET name 指定一个字符集    2.</description>
    </item>
    
    <item>
      <title>MySQL环境搭建</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0_mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0_mysql%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>第02章_MySQL环境搭建 1. MySQL的卸载 步骤1：停止MySQL服务 在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示。
步骤2：软件的卸载 方式1：通过控制面板方式
卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。
方式2：通过360或电脑管家等软件卸载
略
方式3：通过安装包提供的卸载功能卸载
你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。
① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。
② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。
③ 单击“Next”（下一步）按钮，确认卸载。
④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the data directory”，如图所示。
⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。
⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes，Uninstall MySQL Installer”即可，如图所示。
步骤3：残余文件的清理 如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。
（1）服务目录：mysql服务的安装目录
（2）数据目录：默认在C:\ProgramData\MySQL
如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。
 注意：请在卸载前做好数据备份
在操作完以后，需要重启计算机，然后进行安装即可。如果仍然安装失败，需要继续操作如下步骤4。
 步骤4：清理注册表（选做） 如果前几步做了，再次安装还是失败，那么可以清理注册表。
如何打开注册表编辑器：在系统的搜索框中输入regedit
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录删除 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除  注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类
 步骤5：删除环境变量配置 找到path环境变量，将其中关于mysql的环境变量删除，切记不要全部删除。
例如：删除 D:\develop_tools\mysql\MySQLServer8.0.26\bin; 这个部分
2. MySQL的下载、安装、配置 2.1 MySQL的4大版本    MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。</description>
    </item>
    
    <item>
      <title>创建和管理表</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0_%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/</guid>
      <description>第10章_创建和管理表 1. 基础知识 1.1 一条数据存储的过程 存储数据是处理数据的第一步。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。
那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。
我们要先创建一个数据库，而不是直接创建数据表呢？
因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是数据库服务器、数据库、数据表、数据表的行与列。
MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。
1.2 标识符命名规则  数据库名、表名不得超过30个字符，变量名限制为29个 必须只能包含 A–Z, a–z, 0–9, _共63个字符 数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了  1.3 MySQL中的数据类型    类型 类型举例     整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT   浮点类型 FLOAT、DOUBLE   定点数类型 DECIMAL   位类型 BIT   日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP   文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT   枚举类型 ENUM   集合类型 SET   二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB   JSON类型 JSON对象、JSON数组   空间数据类型 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION    其中，常用的几类类型介绍如下：</description>
    </item>
    
    <item>
      <title>单行函数</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0_%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/</guid>
      <description>第07章_单行函数 1. 函数的理解 1.1 什么是函数 函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既提高了代码效率，又提高了可维护性。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。
从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。
1.2 不同DBMS函数的差异 我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着采用 SQL 函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。
1.3 MySQL的内置函数及分类 MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。
MySQL提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：单行函数、聚合函数（或分组函数）。
两种SQL函数
单行函数
 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以嵌套 参数可以是一列或一个值  2. 数值函数 2.1 基本函数    函数 用法     ABS(x) 返回x的绝对值   SIGN(X) 返回X的符号。正数返回1，负数返回-1，0返回0   PI() 返回圆周率的值   CEIL(x)，CEILING(x) 返回大于或等于某个值的最小整数   FLOOR(x) 返回小于或等于某个值的最大整数   LEAST(e1,e2,e3…) 返回列表中的最小值   GREATEST(e1,e2,e3…) 返回列表中的最大值   MOD(x,y) 返回X除以Y后的余数   RAND() 返回0~1的随机值   RAND(x) 返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数   ROUND(x) 返回一个对x的值进行四舍五入后，最接近于X的整数   ROUND(x,y) 返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位   TRUNCATE(x,y) 返回数字x截断为y位小数的结果   SQRT(x) 返回x的平方根。当X的值为负数时，返回NULL    举例：</description>
    </item>
    
    <item>
      <title>变量、流程控制与游标</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0_%E5%8F%98%E9%87%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B8%B8%E6%A0%87/</guid>
      <description>第16章_变量、流程控制与游标 1. 变量 在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。
在 MySQL 数据库中，变量分为系统变量以及用户自定义变量。
1.1 系统变量 1.1.1 系统变量分类 变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。大家可以通过网址 https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html 查看MySQL文档的系统变量。
系统变量分为全局系统变量（需要添加global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。**如果不写，默认会话级别。**静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。
每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：
 全局系统变量针对于所有会话（连接）有效，但不能跨重启 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。  在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。
1.1.2 查看系统变量  查看所有或部分系统变量  #查看所有全局变量 SHOW GLOBAL VARIABLES;  #查看所有会话变量 SHOW SESSION VARIABLES; 或 SHOW VARIABLES; #查看满足条件的部分系统变量。 SHOW GLOBAL VARIABLES LIKE &amp;#39;%标识符%&amp;#39;;  #查看满足条件的部分会话变量 SHOW SESSION VARIABLES LIKE &amp;#39;%标识符%&amp;#39;; 举例：
SHOW GLOBAL VARIABLES LIKE &amp;#39;admin_%&amp;#39;;  查看指定系统变量  作为 MySQL 编码规范，MySQL 中的系统变量以两个“@”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</description>
    </item>
    
    <item>
      <title>基本的SELECT语句</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84select%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0_%E5%9F%BA%E6%9C%AC%E7%9A%84select%E8%AF%AD%E5%8F%A5/</guid>
      <description>第03章_基本的SELECT语句 1. SQL概述 1.1 SQL背景知识   1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。
 45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。    不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。
  SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道，由IBM上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有SQL-86，SQL-89，SQL-92，SQL-99等标准。
 SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。    不同的数据库生产厂商都支持SQL语句，但都有特有内容。
  1.2 SQL语言排行榜 自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。
1.3 SQL 分类 SQL语言在功能上主要分为如下3大类：
  DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。
 主要的语句关键字包括CREATE、DROP、ALTER等。    DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。</description>
    </item>
    
    <item>
      <title>多表查询</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0_%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid>
      <description>第06章_多表查询 多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。
前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。
1. 一个案例引发的多表连接 1.1 案例说明 从多个表中获取数据：
#案例：查询员工的姓名及其部门名称 SELECT last_name, department_name FROM employees, departments; 查询结果：
+-----------+----------------------+ | last_name | department_name | +-----------+----------------------+ | King | Administration | | King | Marketing | | King | Purchasing | | King | Human Resources | | King | Shipping | | King | IT | | King | Public Relations | | King | Sales | | King | Executive | | King | Finance | | King | Accounting | | King | Treasury | .</description>
    </item>
    
    <item>
      <title>子查询</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0_%E5%AD%90%E6%9F%A5%E8%AF%A2/</guid>
      <description>第09章_子查询 子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。
SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。
1. 需求分析与问题解决 1.1 实际问题 现有解决方式：
#方式一： SELECT salary FROM employees WHERE last_name = &amp;#39;Abel&amp;#39;;  SELECT last_name,salary FROM employees WHERE salary &amp;gt; 11000;  #方式二：自连接 SELECT e2.last_name,e2.salary FROM employees e1,employees e2 WHERE e1.last_name = &amp;#39;Abel&amp;#39; AND e1.`salary` &amp;lt; e2.`salary` #方式三：子查询 SELECT last_name,salary FROM employees WHERE salary &amp;gt; ( 	SELECT salary 	FROM employees 	WHERE last_name = &amp;#39;Abel&amp;#39; 	); 1.2 子查询的基本使用  子查询的基本语法结构：   子查询（内查询）在主查询之前一次执行完成。 子查询的结果被主查询（外查询）使用 。 注意事项  子查询要包含在括号内 将子查询放在比较条件的右侧 单行操作符对应单行子查询，多行操作符对应多行子查询    1.</description>
    </item>
    
    <item>
      <title>存储过程与函数</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0_%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/</guid>
      <description>第15章_存储过程与函数 MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。
1. 存储过程概述 1.1 理解 含义：存储过程的英文是 Stored Procedure。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。
执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。
好处：
1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力 2、减少操作过程中的失误，提高效率 3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性
和视图、函数的对比：
它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。
一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。
1.2 分类 存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：
1、没有参数（无参数无返回） 2、仅仅带 IN 类型（有参数无返回） 3、仅仅带 OUT 类型（无参数有返回） 4、既带 IN 又带 OUT（有参数有返回） 5、带 INOUT（有参数有返回）
注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。
2. 创建存储过程 2.1 语法分析 语法：
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...) [characteristics ...] BEGIN 	存储过程体  END 类似于Java中的方法：
修饰符 返回类型 方法名(参数类型 参数名,...){  	方法体; } 说明：</description>
    </item>
    
    <item>
      <title>排序与分页</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0_%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/</guid>
      <description>第05章_排序与分页 1. 排序数据 1.1 排序规则  使用 ORDER BY 子句排序  ASC（ascend）: 升序 DESC（descend）:降序   ORDER BY 子句在SELECT语句的结尾。  1.2 单列排序 SELECT last_name, job_id, department_id, hire_date FROM employees ORDER BY hire_date ; SELECT last_name, job_id, department_id, hire_date FROM employees ORDER BY hire_date DESC ; SELECT employee_id, last_name, salary*12 annsal FROM employees ORDER BY annsal; 1.3 多列排序 SELECT last_name, department_id, salary FROM employees ORDER BY department_id, salary DESC;  可以使用不在SELECT列表中的列排序。 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。  2.</description>
    </item>
    
    <item>
      <title>数据处理之增删改</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</guid>
      <description>第11章_数据处理之增删改 1. 插入数据 1.1 实际问题 解决方式：使用 INSERT 语句向表中插入数据。
1.2 方式1：VALUES的方式添加 使用这种语法一次只能向表中插入一条数据。
情况1：为表的所有字段按默认顺序插入数据
INSERT INTO 表名 VALUES (value1,value2,....); 值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。
举例：
INSERT INTO departments VALUES (70, &amp;#39;Pub&amp;#39;, 100, 1700); INSERT INTO	departments VALUES	(100, &amp;#39;Finance&amp;#39;, NULL, NULL); 情况2：为表的指定字段插入数据
INSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]); 为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。
在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,&amp;hellip;.valuen需要与column1,&amp;hellip;columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。
举例：
INSERT INTO departments(department_id, department_name) VALUES (80, &amp;#39;IT&amp;#39;); 情况3：同时插入多条记录
INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：
INSERT INTO table_name VALUES (value1 [,value2, …, valuen]), (value1 [,value2, …, valuen]), …… (value1 [,value2, …, valuen]); 或者</description>
    </item>
    
    <item>
      <title>数据库概述</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</guid>
      <description>第01章_数据库概述 1. 为什么要使用数据库  持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。  生活中的例子：
2. 数据库与数据库管理系统 2.1 数据库的相关概念    DB：数据库（Database）     即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。   DBMS：数据库管理系统（Database Management System）   是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。   SQL：结构化查询语言（Structured Query Language）   专门用来与数据库通信的语言。    2.2 数据库与数据库管理系统的关系 数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。
数据库管理系统、数据库和表的关系如图所示：
2.3 常见的数据库管理系统排名(DBMS) 目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年DB-Engines Ranking 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking）
。。。
对应的走势图：（https://db-engines.com/en/ranking_trend）
2.4 常见的数据库介绍 Oracle
1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。
2007年，总计85亿美金收购BEA Systems。
2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</description>
    </item>
    
    <item>
      <title>约束</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0_%E7%BA%A6%E6%9D%9F/</guid>
      <description>第13章_约束 1. 约束(constraint)概述 1.1 为什么需要约束 数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。
为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：
 实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录 域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女” 引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门 用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。  1.2 什么是约束 约束是表级的强制规定。
可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束。
1.3 约束的分类  **根据约束数据列的限制，**约束可分为：  单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据   根据约束的作用范围，约束可分为：  列级约束：只能作用在一个列上，跟在列的定义后面 表级约束：可以作用在多个列上，不与列一起，而是单独定义    	位置	支持的约束类型	是否可以起约束名 列级约束：	列的后面	语法都支持，但外键没有效果	不可以 表级约束：	所有列的下面	默认和非空不支持，其他支持	可以（主键没有效果）  根据约束起的作用，约束可分为：  NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束 FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束     注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</description>
    </item>
    
    <item>
      <title>聚合函数</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0_%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</guid>
      <description>第08章_聚合函数 我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。
1. 聚合函数介绍  什么是聚合函数  聚合函数作用于一组数据，并对一组数据返回一个值。
  聚合函数类型
 AVG() SUM() MAX() MIN() **COUNT() **    聚合函数语法
   聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。  1.1 AVG和SUM函数 可以对数值型数据使用AVG 和 SUM 函数。
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE &amp;#39;%REP%&amp;#39;; 1.2 MIN和MAX函数 可以对任意数据类型的数据使用 MIN 和 MAX 函数。
SELECT MIN(hire_date), MAX(hire_date) FROM	employees; 1.3 COUNT函数  COUNT(*)返回表中记录总数，适用于任意数据类型。  SELECT COUNT(*) FROM	employees WHERE department_id = 50;  COUNT(expr) 返回expr不为空的记录总数。  SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50;   问题：用count(*)，count(1)，count(列名)谁好呢?</description>
    </item>
    
    <item>
      <title>视图</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0_%E8%A7%86%E5%9B%BE/</guid>
      <description>第14章_视图 1. 常见的数据库对象    对象 描述     表(TABLE) 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录   数据字典 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看   约束(CONSTRAINT) 执行数据校验的规则，用于保证数据完整性的规则   视图(VIEW) 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据   索引(INDEX) 用于提高查询性能，相当于书的目录   存储过程(PROCEDURE) 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境   存储函数(FUNCTION) 用于完成一次特定的计算，具有一个返回值   触发器(TRIGGER) 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理    2. 视图概述 2.1 为什么使用视图？ 视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。
刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。
2.2 视图的理解   视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。
  视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。
  视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。
  向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句</description>
    </item>
    
    <item>
      <title>触发器</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0_%E8%A7%A6%E5%8F%91%E5%99%A8/</guid>
      <description>第17章_触发器 在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如商品信息和库存信息分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。
这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。
这个时候，咱们可以使用触发器。**你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。**这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。
1. 触发器概述 MySQL从5.0.2版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。
触发器是由事件来触发某个操作，这些事件包括INSERT、UPDATE、DELETE事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。
当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。
2. 触发器的创建 2.1 创建触发器语法 创建触发器的语法结构是：
CREATE TRIGGER 触发器名称 {BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名 FOR EACH ROW 触发器执行的语句块; 说明：
  表名：表示触发器监控的对象。
  BEFORE|AFTER：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。
  INSERT|UPDATE|DELETE：表示触发的事件。
 INSERT 表示插入记录时触发； UPDATE 表示更新记录时触发； DELETE 表示删除记录时触发。    触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。
  2.2 代码举例 举例1：
1、创建数据表：
CREATE TABLE test_trigger ( id INT PRIMARY KEY AUTO_INCREMENT, t_note VARCHAR(30) );   CREATE TABLE test_trigger_log ( id INT PRIMARY KEY AUTO_INCREMENT, t_log VARCHAR(30) ); 2、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</description>
    </item>
    
    <item>
      <title>运算符</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Tue, 13 Dec 2022 15:29:33 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0_%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>1. 算术运算符 算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。
1．加法与减法运算符
mysql&amp;gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual; +-----+---------+---------+----------+--------------+------------+------------+ | 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 | +-----+---------+---------+----------+--------------+------------+------------+ | 100 | 100 | 100 | 150 | 120 | 135.5 | 64.</description>
    </item>
    
    <item>
      <title>Jenkins</title>
      <link>https://jiayi26.github.io/posts/jenkins/</link>
      <pubDate>Tue, 06 Dec 2022 15:21:29 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/jenkins/</guid>
      <description>1. Jenkins 的概述 1.1 Jenkins是什么 Jenkins 是一款开源 CI&amp;amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。
1.2 Jenkins的优点  持续集成和持续交付 易于安装部署配置 丰富的插件支持 分布式构建  2. 持续集成（Continuous Integration） 2.1 什么是持续集成？  定义：持续频繁的（每天多次）将本地代码“集成”到主干分支，并保证主干分支可用。 目的：是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 持续集成并不能消除Bug，而是让它们非常容易发现和改正。  2.2 持续集成的好处?  通过自动化手段提高集成速度，减少维护成本 将问题前置，每次 commit 时就触发编译、测试，更快的发现问题 防止本地代码大幅偏离主干，如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。  2.3 触发方式 自动触发，通过自动化的 CI 服务或工具，自动监听代码库 Git Push &amp;amp; MR 等事件触发。常见的工具如 Jenkins、GitlabCI、CircleCI、GithubActions 等等
3. 持续交付（Continuous Delivery） 3.1 什么是持续交付？ 定义：是持续集成的下一步，持续频繁地将软件的新版本交付到类生产环境（类似于预发），交付给测试、产品验收。持续交付强调的是“交付”，不管怎么更新，软件是随时随地可以交付的，相比持续集成，持续交付除了交付到类生产环境之外，还会执行一些集成测试、API测试等等，确保交付的产物可以直接交付部署。
3.2 触发方式 手动触发，通过研发平台手动触发（如触发LinkE预发部署流水线），一般交付结果是一个二进制包或者镜像。
4. 持续部署（Continuous Deployment） 4.1 什么是持续部署？ 定义：是持续交付的下一步，“自动”将代码部署到生产环境。持续部署强调的是“部署”，它的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。持续部署和持续交付触发方式的区别是，持续部署是自动完成的，持续交付是手动完成的
4.2 触发方式 自动触发，通过研发平台配置定时任务，自动获取交付产物进行自动部署。 本文章用到的软件工具：</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://jiayi26.github.io/posts/git/</link>
      <pubDate>Fri, 25 Nov 2022 17:19:25 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/git/</guid>
      <description>1. Git的概述 Git 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。
2. 什么是版本控制？ 记录文件内容变化，最重要的是记录文件修改历史记录。
3. Git的三种状态  已修改（modified） - 已修改表示修改了文件，但还没保存到数据库中 已暂存（staged） - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 已提交（committed） - 已提交表示数据已经安全的保存在本地数据库中  4. Git的四个区域  工作区（workspace）：当你 git clone 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改 暂存区（staging area）：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作 ‘索引’，不过一般说法还是叫暂存区 本地仓库（local repository）：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库 远程仓库（remote repository）：以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新  5. Git命令    命令 说明     git config &amp;ndash;global user.name 用户名 设置用户签名   git config &amp;ndash;global user.email email地址 设置用户email地址   git init 初始化本地库   git clone 远程库地址 从远程库克隆到本地   git status 查看本地库状态   git add 添加文件到暂存区   git restore &amp;ndash;staged 文件名 复位在暂存区的文件(add反悔药)   git rm &amp;ndash;cached 文件名 移除在暂存区的文件(add反悔药)   git commit -m “备注文本” 文件名 提交暂存区文件到本地库（文件名缺省时，将暂存区所有文件提交）   git reset &amp;ndash;hard 版本号 版本间穿梭(配合git reflog使用)   git reset &amp;ndash;hard HEAD^ 穿梭到上一个版本   git branch 列出所有分支   git branch 分支名 创建分支   git checkout 分支名 切换分支   git merge 分支名B 分支B合并到A(A为当前工作目录所处分支)   git branch -d 分支名 删除分支   git remote add 别名 远程仓库地址 添加远程库   git remote -v 查看添加过的远程库   git push 远程库地址或其别名 分支名 推送到远程库   git pull 远程库地址或其别名 分支名 下载远程代码并合并   git diff 比较文件的不同   git log 查看历史提交记录   git reflog 可以查看所有分支的所有操作记录    Git常用命令演示 5.</description>
    </item>
    
    <item>
      <title>TCP三次握手和四次挥手</title>
      <link>https://jiayi26.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</link>
      <pubDate>Fri, 28 Oct 2022 21:33:57 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</guid>
      <description>TCP三次握手 (1)第一次握手：客户端发送连接请求报文，SYN=1，seq=x，进入 SYN_SENT 状态，等待服务器确认 (2)第二次握手：服务器收到请求报文，确认请求报文后发送 SYN+ack 包，SYN=1，ack=x+1，seq=y，进入 SYN_RECV 状态 (3)第三次握手：客户端收到服务器的 SYN+ack 包，向服务器发送 ack 包 SYN=1，ack=y+1，seq=x+1，进入ESTABLISHED状态
 序列号(Sequence Number)：发送数据包中的第一个字节的序列号，保证网络传输数据的有序性 确认应答号(Acknowledgement Number)：表示已经收到数据包，用来解决网络中丢包的问题 ACK：为1时，确认应答号有效 SYN：为1时，发起一个连接（在建立TCP连接的时候使用） FIN：为1时，关闭一个连接（在关闭TCP连接的时候使用）
 TCP四次挥手 (1)第一次挥手：客户端进程发出连接释放报文，FIN=1，seq=u，客户端进入 FIN-WAIT-1（终止等待1）状态 (2)第二次挥手：服务器收到连接释放报文，发出确认报文 ack=u+1，seq=v，进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间 (3)第三次挥手：客户端收到服务器的确认请求后，客户端就进入FIN-WAIT-2（终止等待2）状态。等待服务器发送连接释放报文。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，seq=w，进入了LAST-ACK（最后确认）状态。 (4)第四次挥手：客户端收到服务器的连接释放报文后，发出确认报文 ack=w+1，seq=u+1，客户端就进入了TIME-WAIT（时间等待）状态。此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间，才进入CLOSED状态
为什么连接的时候是三次握手，关闭的时候却是四次握手？ 当客户端发出FIN报文时，只是表示Client已经没有数据要发送了，这个时候Client还是可以接受来自Server的数据。当Server收到FIN报文时，会先回复一个ACK报文，告诉Client，&amp;ldquo;你发的FIN报文我收到了&amp;rdquo;。只有等Server所有的报文都发送完，才会发送FIN报文。
为什么要等待2MSL？ 为了保证Client发送的最后一个ACK报文段能够到达Server Client发送的ACK报文可能丢失，Server如果没有收到ACK，将不断重复发送FIN报文。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK报文并再次等待2MSL
 MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
 防止已经失效的连接请求报文段出现在新连接中 Client在发送完最后一个ACK报文段后，再经过时间2MSL。就可以使本连接持续的时间内所产生的所有报文段都在网络中消失。这样就可以在下一个新的连接中不会出现这种旧的连接请求报文段。</description>
    </item>
    
    <item>
      <title>Kubernetes概念</title>
      <link>https://jiayi26.github.io/posts/kubernetes%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 16 Aug 2022 22:23:48 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/kubernetes%E6%A6%82%E5%BF%B5/</guid>
      <description>Kubernetes是什么？ Kubernetes 是一个生产级别的容器编排平台和集群管理系统。用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。
传统部署时代 早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程式资源利用率不高时，剩余资源无法被分配给其他应用程式， 而且维护许多物理服务器的成本很高。
虚拟化部署时代 因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。
虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。
每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
容器部署时代 容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。
容器因具有许多优势而变得流行起来，例如：
 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。 关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。  Kubernetes能做什么？ 容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？</description>
    </item>
    
    <item>
      <title>Kubernetes环境搭建</title>
      <link>https://jiayi26.github.io/posts/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 16 Aug 2022 22:23:09 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>minikube 下载安装minikube Intel x86_64 curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube Apple arm64 curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64 sudo install minikube /usr/local/bin/ 安装完成之后，你可以执行命令 minikube version，看看它的版本号，验证是否安装成功：
[root@localhost ~]# minikube version minikube version: v1.28.0 安装kubectl minikube kubectl 验证 minikube 环境 前面的工作都做完之后，我们就可以在本机上运行 minikube，创建 Kubernetes 实验环境了。 使用命令 minikube start 会从 Docker Hub 上拉取镜像，以当前最新版本的 Kubernetes 启动集群。不过为了保证实验环境的一致性，我们可以在后面再加上一个参数 &amp;ndash;kubernetes-version，明确指定要使用 Kubernetes 版本。 这里我使用“1.23.3”，启动命令就是（启动 k8s 集群使用root用户时，要加上&amp;ndash;force命令，使用国内镜像，要加上&amp;ndash;image-mirror-country=&amp;lsquo;cn&amp;rsquo;）：
minikube start --kubernetes-version=v1.23.3 --force --image-mirror-country=&amp;#39;cn&amp;#39; 现在 Kubernetes 集群就已经在我们本地运行了，你可以使用 minikube status、minikube node list这两个命令来查看集群的状态：
minikube status minikube node list 有了集群，接下来我们就可以使用 kubectl 来操作一下，初步体会 Kubernetes 这个容器编排系统，最简单的命令当然就是查看版本：</description>
    </item>
    
    <item>
      <title>Kubernetes组件</title>
      <link>https://jiayi26.github.io/posts/kubernetes%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Tue, 16 Aug 2022 22:23:09 +0800</pubDate>
      
      <guid>https://jiayi26.github.io/posts/kubernetes%E7%BB%84%E4%BB%B6/</guid>
      <description>Kubernetes 的基本架构 Kubernetes 采用了现今流行的“控制面 / 数据面”（Control Plane / Data Plane）架构，集群里的计算机被称为“节点”（Node），可以是实机也可以是虚机，少量的节点用作控制面来执行集群的管理维护工作，其他的大部分节点都被划归数据面，用来跑业务应用。
控制面的节点在 Kubernetes 里叫做 Master Node，一般简称为 Master，它是整个集群里最重要的部分，可以说是 Kubernetes 的大脑和心脏。
数据面的节点叫做 Worker Node，一般就简称为 Worker 或者 Node，相当于 Kubernetes 的手和脚，在 Master 的指挥下干活。
Node 的数量非常多，构成了一个资源池，Kubernetes 就在这个池里分配资源，调度应用。因为资源被“池化”了，所以管理也就变得比较简单，可以在集群中任意添加或者删除节点。 Master组件 Master组件为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 replicas 字段时， 要启动新的 pod）。
控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。
apiserver 是整个 Kubernetes 系统的唯一入口，它对外公开了一系列的 RESTful API，并且加上了验证、授权等功能，所有其他组件都只能和它直接通信，可以说是 Kubernetes 里的联络员。
etcd 是一个高可用的分布式 Key-Value 数据库，用来持久化存储系统里的各种资源对象和状态，相当于 Kubernetes 里的配置管理员。注意它只与 apiserver 有直接联系，也就是说任何其他组件想要读写 etcd 里的数据都必须经过 apiserver。
scheduler 负责容器的编排工作，检查节点的资源状态，把 Pod 调度到最适合的节点上运行，相当于部署人员。因为节点状态和 Pod 信息都存储在 etcd 里，所以 scheduler 必须通过 apiserver 才能获得。</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://jiayi26.github.io/posts/docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/docker/</guid>
      <description>Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &amp;ldquo;Build，Ship and Run Any App,Anywhere&amp;rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ &amp;gt; docker-client \ &amp;gt; docker-client-latest \ &amp;gt; docker-common \ &amp;gt; docker-latest \ &amp;gt; docker-latest-logrotate \ &amp;gt; docker-logrotate \ &amp;gt; docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的</description>
    </item>
    
    <item>
      <title>InnoDB数据存储结构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</guid>
      <description>第07章 InnoDB数据存储结构 1. 数据库的存储结构：页 索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。
由于InnoDB是MySQL的默认存储引擎，所以本章剖析InooDB存储引擎的数据存储结构。
1.1 磁盘与内存交互基本单位：页 InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16KB。
以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。**一个页中可以存储多个行记录。
 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。
 1.2 页结构概述 页a、页b、页c&amp;hellip;页n这些页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。
1.3 页的上层结构 区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。
段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。
表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。
2. 页的内部结构 2.1 第1部分：文件头部和文件尾部 2.1.1 File Header（文件头部）（38字节） 作用： 描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）
大小：38字节
   名称 占用空间大小 描述     FIL_PAGE_SPACE_OR_CHKSUM 4字节 页的校验和（checksum值）   FIL_PAGE_OFFSET 4字节 页号   FIL_PAGE_PREV 4字节 上一个页的页号   FIL_PAGE_NEXT 4字节 下一个页的页号   FIL_PAGE_LSN 8字节 页面被最后修改时对应的日志序列位置   FIL_PAGE_TYPE 2字节 该页的类型   FIL_PAGE_FILE_FLUSH_LSN 8字节 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值   FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID 4字节 页属于哪个表空间     FIL_PAGE_OFFSET（4字节）：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。 FIL_PAGE_TYPE（2字节）：这个代表当前页的类型。     类型名称 十六进制 描述     FIL_PAGE_TYPE_ALLOCATED 0x0000 最新分配，还没有使用   FIL_PAGE_UNDO_LOG 0x0002 Undo日志页   FIL_PAGE_INODE 0x0003 段信息节点   FIL_PAGE_IBUF_FREE_LIST 0x0004 Insert Buffer空闲列表   FIL_PAGE_IBUF_BITMAP 0x0005 Insert Buffer位图   FIL_PAGE_TYPE_SYS 0x0006 系统页   FIL_PAGE_TYPE_TRX_SYS 0x0007 事务系统数据   FIL_PAGE_TYPE_FSP_HDR 0x0008 表空间头部信息   FIL_PAGE_TYPE_XDES 0x0009 扩展描述页   FIL_PAGE_TYPE_BLOB 0x000A 溢出页   FIL_PAGE_INDEX 0x45BF 索引页，也就是我们所说的数据页     FIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。 FIL_PAGE_SPACE_OR_CHKSUM（4字节）：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM  作用：</description>
    </item>
    
    <item>
      <title>Linux下MySQL的安装与使用</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0-linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC01%E7%AB%A0-linux%E4%B8%8Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>第01章 Linux下MySQL的安装与使用 1. 安装前说明 1.1 查看是否安装过MySQL  如果你是用rpm安装, 检查一下RPM PACKAGE：  rpm -qa | grep -i mysql # -i 忽略大小写  检查mysql service：  systemctl status mysqld.service 1.2 MySQL的卸载 1. 关闭 mysql 服务
systemctl stop mysqld.service 2. 查看当前 mysql 安装状况
rpm -qa | grep -i mysql # 或 yum list installed | grep mysql 3. 卸载上述命令查询出的已安装程序
yum remove mysql-xxx mysql-xxx mysql-xxx mysqk-xxxx 务必卸载干净，反复执行rpm -qa | grep -i mysql确认是否有卸载残留
4. 删除 mysql 相关文件</description>
    </item>
    
    <item>
      <title>Linux性能分析工具</title>
      <link>https://jiayi26.github.io/posts/linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid>
      <description>CPU性能分析工具 内存性能分析工具 磁盘 I/O 性能工具 网络性能工具 </description>
    </item>
    
    <item>
      <title>MySQL事务日志</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</guid>
      <description>第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？
 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。
1.2 REDO日志的好处、特点 1. 好处
 redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点
 redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：
 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：
redo log buffer 大小，默认16M，最大值是4096M，最小值为1M。
 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</description>
    </item>
    
    <item>
      <title>MySQL的数据目录</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</guid>
      <description>第02章 MySQL的数据目录 1. MySQL8的主要目录结构 find / -name mysql 1.1 数据库文件的存放路径 show variables like &amp;#39;datadir&amp;#39;; # /var/lib/mysql/ 1.2 相关命令目录 相关命令目录：/usr/bin 和/usr/sbin。
1.3 配置文件目录 配置文件目录：/usr/share/mysql-8.0（命令及配置文件），/etc/mysql（如my.cnf）
2. 数据库和文件系统的关系 2.1 表在文件系统中的表示 2.3.1 InnoDB存储引擎模式 1. 表结构
为了保存表结构，InnoDB在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件
表名.frm 2. 表中数据和索引
① 系统表空间（system tablespace）
默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的自拓展文件，这个文件就是对应的系统表空间在文件系统上的表示。
② 独立表空间(file-per-table tablespace)
在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同。
表名.ibd  MySQL8.0中不再单独提供表名.frm，而是合并在表名.ibd文件中。
 ③ 系统表空间与独立表空间的设置
我们可以自己指定使用系统表空间还是独立表空间来存储数据，这个功能由启动参数innodb_file_per_table控制
[server]  innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间 ④ 其他类型的表空间
随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、临时表空间（temporary tablespace）等。
2.3.2 MyISAM存储引擎模式 1. 表结构
在存储表结构方面， MyISAM 和 InnoDB 一样，也是在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件</description>
    </item>
    
    <item>
      <title>主从复制</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC18%E7%AB%A0-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>第18章 主从复制 1. 主从复制概述 1.1 如何提升数据库并发能力 一般应用对数据库而言都是“读多写少”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做主从架构、进行读写分离，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。
如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化SQL和索引，这种方式简单有效；其次才是采用缓存的策略，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用主从架构，进行读写分离。
1.2 主从复制的作用 第1个作用：读写分离。
第2个作用就是数据备份。
第3个作用是具有高可用性。
2. 主从复制的原理 2.1 原理剖析 三个线程
实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于3 个线程来操作，一个主库线程，两个从库线程。
二进制日志转储线程（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。
从库 I/O 线程会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。
从库 SQL 线程会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。
复制三步骤
步骤1：Master将写操作记录到二进制日志（binlog）。
步骤2：Slave将Master的binary log events拷贝到它的中继日志（relay log）；
步骤3：Slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。
复制的问题
复制的最大问题：延时
2.2 复制的基本原则   每个Slave只有一个Master
  每个Slave只能有一个唯一的服务器ID
  每个Master可以有多个Slave
  3. 同步数据一致性问题 主从同步的要求：
  读库和写库的数据一致(最终一致)；</description>
    </item>
    
    <item>
      <title>事务基础知识</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>第13章 事务基础知识 1. 数据库事务概述 1.1 基本概念 **事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。
**事务处理的原则：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。
1.2 事务的ACID特性  原子性（atomicity）：  原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。
 一致性（consistency）：  一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。
 隔离型（isolation）：  事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
 持久性（durability）：  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。
1.3 事务的状态  活动的（active）  事务对应的数据库操作正在执行过程中时，我们就说该事务处在活动的状态。
 部分提交的（partially committed）  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。
 失败的（failed）  当事务处在活动的或者部分提交的状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。
 中止的（aborted）  如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。
 提交的（committed）  当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。
2. 如何使用事务 2.1 显式事务 步骤1： START TRANSACTION或者BEGIN，作用是显式开启一个事务。
mysql&amp;gt; BEGIN; #或者 mysql&amp;gt; START TRANSACTION; START TRANSACTION语句相较于BEGIN特别之处在于，后边能跟随几个修饰符：
①READ ONLY：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。
②READ WRITE：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。
③WITH CONSISTENT SNAPSHOT：启动一致性读。</description>
    </item>
    
    <item>
      <title>其它数据库日志</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0-%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC17%E7%AB%A0-%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97/</guid>
      <description>第17章 其它数据库日志 1. MySQL支持的日志 1.1 日志类型 MySQL有不同类型的日志文件，用来存储不同类型的日志，分为二进制日志、错误日志、通用查询日志和慢查询日志，这也是常用的4种。MySQL 8又新增两种支持的日志：中继日志和数据定义语句日志。使用这些日志文件，可以查看MySQL内部发生的事情。
  **慢查询日志：**记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。
  **通用查询日志：**记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
  **错误日志：**记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。
  **二进制日志：**记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
  **中继日志：**用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
  **数据定义语句日志：**记录数据定义语句执行的元数据操作。
  除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。
1.2 日志的弊端   日志功能会降低MySQL数据库的性能。
  日志会占用大量的磁盘空间。
  2. 通用查询日志(general query log) 通用查询日志用来记录用户的所有操作，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。
2.1 查看当前状态 mysql&amp;gt; SHOW VARIABLES LIKE &amp;#39;%general%&amp;#39;; 2.2 启动日志 方式1：永久性方式
[mysqld]  general_log=ON  general_log_file=[path[filename]] #日志文件所在目录路径，filename为日志文件名 方式2：临时性方式
SET GLOBAL general_log=on; # 开启通用查询日志 SET GLOBAL general_log_file=’path/filename’; # 设置日志文件保存位置 SET GLOBAL general_log=off; # 关闭通用查询日志 SHOW VARIABLES LIKE &amp;#39;general_log%&amp;#39;; # 查看设置后情况 2.</description>
    </item>
    
    <item>
      <title>多版本并发控制</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</guid>
      <description>第16章 多版本并发控制 1. 什么是MVCC MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。
2. 快照读与当前读 MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读，而这个读指的就是快照读, 而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。
2.1 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即不加锁的非阻塞读。
之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。
既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。
快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。
2.2 当前读 当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。
3. 复习 3.1 再谈隔离级别 我们知道事务有 4 个隔离级别，可能存在三种并发问题：
另图：
3.2 隐藏字段、Undo Log版本链 回顾一下undo日志的版本链，对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。
 trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id 隐藏列。 roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 undo日志 中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。  4. MVCC实现原理之ReadView MVCC 的实现依赖于：隐藏字段、Undo Log、Read View。
4.1 什么是ReadView ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID（“活跃”指的就是，启动了但还没提交）。
4.2 设计思路 使用READ UNCOMMITTED隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。
使用SERIALIZABLE隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。
使用READ COMMITTED和REPEATABLE READ隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。
这个ReadView中主要包含4个比较重要的内容，分别如下：
 creator_trx_id，创建这个 Read View 的事务 ID。   说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</description>
    </item>
    
    <item>
      <title>存储引擎</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC05%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>第05章 存储引擎 1. 查看存储引擎 show engines; # 或 show engines\G 2. 设置系统默认的存储引擎  查看默认的存储引擎：  show variables like &amp;#39;%storage_engine%&amp;#39;; #或 SELECT @@default_storage_engine;  修改默认的存储引擎  如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用InnoDB作为表的存储引擎。
SET DEFAULT_STORAGE_ENGINE=MyISAM; 或者修改my.cnf文件：
default-storage-engine=MyISAM  # 重启服务  systemctl restart mysqld.service 3. 设置表的存储引擎 存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。
3.1 创建表时指定存储引擎 CREATE TABLE 表名(  建表语句; ) ENGINE = 存储引擎名称; 3.2 修改表的存储引擎 ALTER TABLE 表名 ENGINE = 存储引擎名称; 4. 引擎介绍 4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎  MySQL从3.23.34a开始就包含InnoDB存储引擎。大于等于5.5之后，默认采用InnoDB引擎。 InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 数据文件结构：  表名.</description>
    </item>
    
    <item>
      <title>性能分析工具的使用</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC09%E7%AB%A0-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>第09章 性能分析工具的使用 1. 统计SQL的查询成本：last_query_cost SHOW STATUS LIKE &amp;#39;last_query_cost&amp;#39;; 使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。
 SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：
 位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。  所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。
 2. 定位执行慢的SQL：慢查询日志 MySQL的慢查询日志，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time的值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。
默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。
2.1 开启慢查询日志参数 1. 开启slow_query_log
set global slow_query_log=&amp;#39;ON&amp;#39;; 查看下慢查询日志是否开启，以及慢查询日志文件的位置：
show variables like `%slow_query_log%`; 2. 修改long_query_time阈值
show variables like &amp;#39;%long_query_time%&amp;#39;; #测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并 执行下述语句 mysql &amp;gt; set global long_query_time = 1; mysql&amp;gt; show global variables like &amp;#39;%long_query_time%&amp;#39;;  mysql&amp;gt; set long_query_time=1; mysql&amp;gt; show variables like &amp;#39;%long_query_time%&amp;#39;; 2.2 查看慢查询数目 SHOW GLOBAL STATUS LIKE &amp;#39;%Slow_queries%&amp;#39;; 2.</description>
    </item>
    
    <item>
      <title>数据库其它调优策略</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC12%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</guid>
      <description>第12章 数据库其它调优策略 1. 数据库调优的措施 1.1 调优的目标  尽可能节省系统资源，以便系统可以提供更大负荷的服务。（吞吐量更大） 合理的结构设计和参数调整，以提高用户操 响应的速度。（响应速度更快） 减少系统的瓶颈，提高MySQL数据库整体的性能。  1.2 如何定位调优问题  用户的反馈（主要） 日志分析（主要） 服务器资源使用监控 数据库内部状况监控 其它  1.3 调优的维度和步骤 第1步：选择适合的 DBMS
第2步：优化表设计
第3步：优化逻辑查询
第4步：优化物理查询
物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。
第5步：使用 Redis 或 Memcached 作为缓存
第6步：库级优化
1、读写分离
2、数据分片
2. 优化MySQL服务器 2.1 优化服务器硬件 **服务器的硬件性能直接决定着MySQL数据库的性能。**硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。
（1）配置较大的内存
（2）配置高速磁盘系统
（3）合理分布磁盘I/O
（4）配置多处理器
2.2 优化MySQL的参数  innodb_buffer_pool_size：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存表的数据。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。 key_buffer_size：表示索引缓冲区的大小。索引缓冲区是所有的线程共享。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。 table_cache：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。 query_cache_size：表示查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。 query_cache_type的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓存区内存。  当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定SQL_NO_CACHE，如SELECT SQL_NO_CACHE * FROM tbl_name。 当query_cache_type=2时，只有在查询语句中使用SQL_CACHE关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。   sort_buffer_size：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高ORDER BY或GROUP BY操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。 join_buffer_size = 8M：表示联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。 read_buffer_size：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参数的值。默认为64K，可以设置为4M。 innodb_flush_log_at_trx_commit：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。  值为0时，表示每秒1次的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。 值为1时，表示每次提交事务时将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。 值为2时，表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。该模式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。   innodb_log_buffer_size：这是 InnoDB 存储引擎的事务日志所使用的缓冲区。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。 max_connections：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。 back_log：用于控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.</description>
    </item>
    
    <item>
      <title>数据库备份与恢复</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC19%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC19%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid>
      <description>第19章 数据库备份与恢复 1. 物理备份与逻辑备份 物理备份：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用xtrabackup工具来进行物理备份。
逻辑备份：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为mysqldump。逻辑备份就是备份sql语句，在恢复的时候执行备份的sql语句实现数据库数据的重现。
2. mysqldump实现逻辑备份 2.1 备份一个数据库 mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&amp;gt; 备份文件名 称.sql mysqldump -uroot -p atguigu&amp;gt;atguigu.sql #备份文件存储在当前目录下 mysqldump -uroot -p atguigudb1 &amp;gt; /var/lib/mysql/atguigu.sql 2.2 备份全部数据库 mysqldump -uroot -pxxxxxx --all-databases &amp;gt; all_database.sql mysqldump -uroot -pxxxxxx -A &amp;gt; all_database.sql 2.3 备份部分数据库 mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &amp;gt; 备份文件名 称.sql mysqldump -uroot -p --databases atguigu atguigu12 &amp;gt;two_database.sql mysqldump -uroot -p -B atguigu atguigu12 &amp;gt; two_database.</description>
    </item>
    
    <item>
      <title>数据库的设计规范</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
1.3 键和相关属性的概念 这里有两个表：
球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team)：球队编号 | 主教练 | 球队所在地
 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。
1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&amp;quot;A&amp;ndash;&amp;gt;B&amp;ndash;&amp;gt;C&amp;quot;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。
1.7 小结 关于数据表的设计，有三个范式要遵循。
（1）第一范式（1NF），确保每列保持原子性
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
（2）第二范式（2NF），确保每列都和主键完全依赖
尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。
（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关
**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。
范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。
2. 反范式化 2.1 概述 规范化 vs 性能
  为满足某种商业目标 , 数据库性能比规范化数据库更重要</description>
    </item>
    
    <item>
      <title>用户与权限管理</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>第03章 用户与权限管理 1. 用户管理 1.1 登录MySQL服务器 启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：
mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &amp;#34;SQL语句&amp;#34;  -h参数后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 -P参数后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。 -u参数后面接用户名，username为用户名。 -p参数会提示输入密码。 DatabaseName参数指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。 -e参数后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。  mysql -uroot -p -hlocalhost -P3306 mysql -e &amp;#34;select host,user from user&amp;#34; 1.2 创建用户 CREATE USER 用户名 [IDENTIFIED BY &amp;#39;密码&amp;#39;][,用户名 [IDENTIFIED BY &amp;#39;密码&amp;#39;]]; 举例：
CREATE USER zhang3 IDENTIFIED BY &amp;#39;123123&amp;#39;; # 默认host是 % CREATE USER &amp;#39;kangshifu&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;123456&amp;#39;; 1.3 修改用户 UPDATE mysql.user SET USER=&amp;#39;li4&amp;#39; WHERE USER=&amp;#39;wang5&amp;#39;; FLUSH PRIVILEGES; 1.</description>
    </item>
    
    <item>
      <title>索引优化与查询优化</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。
 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。
1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。
1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）
 1.7 不等于(!= 或者&amp;lt;&amp;gt;)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&amp;rsquo;&#39;)
拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描
 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。
1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。
2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现
结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表
结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表
 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。</description>
    </item>
    
    <item>
      <title>索引的创建与设计原则</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>第08章 索引的创建与设计原则 1. 索引的声明与使用 1.1 索引的分类  从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数进行划分，分成单列索引和联合索引。  1.2 创建索引 CREATE TABLE table_name [col_name data_type] [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC | DESC]  UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引； INDEX与KEY为同义词，两者的作用相同，用来指定创建索引； index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； ASC或DESC指定升序或者降序的索引值存储。  1. 创建普通索引
CREATE TABLE book(  book_id INT ,  book_name VARCHAR(100),  authors VARCHAR(100),  info VARCHAR(100) ,  comment VARCHAR(100),  year_publication YEAR,  INDEX(year_publication) ); 2.</description>
    </item>
    
    <item>
      <title>索引的数据结构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC06%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>第06章 索引的数据结构 1. 索引及其优缺点 1.1 索引概述 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。
1.2 优点 （1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因。
（2）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
（4）在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了CPU的消耗。
1.3 缺点 （1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。
（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
（3）虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
2. InnoDB中索引的推演 2.1 索引之前的查找 SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 1.在一个页中的查找
假设目前表中的记录比较少，所有的记录都可以被存放在一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
 以主键为搜索条件  可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。   以其他列作为搜索条件  因为在数据页中并没有对非主键建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。    2.在很多页中查找
大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：
 定位到记录所在的页。 从所在的页内查找相应的记录。  在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。
2.2 设计索引 mysql&amp;gt; CREATE TABLE index_demo(  -&amp;gt; c1 INT,  -&amp;gt; c2 INT,  -&amp;gt; c3 CHAR(1),  -&amp;gt; PRIMARY KEY(c1)  -&amp;gt; ) ROW_FORMAT = Compact; 这个新建的index_demo表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键，这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</description>
    </item>
    
    <item>
      <title>逻辑架构</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC04%E7%AB%A0-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid>
      <description>第04章 逻辑架构 1. 逻辑架构剖析 1.1 第1层：连接层 系统（客户端）访问MySQL服务器前，做的第一件事就是建立TCP连接。
经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。
 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限  TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。
1.2 第2层：服务层   SQL Interface: SQL接口
 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT &amp;hellip; FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口    Parser: 解析器
 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。    Optimizer: 查询优化器
 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。 这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。 它使用“选取-投影-连接”策略进行查询。例如：  SELECT id,name FROM student WHERE gender = &amp;#39;女&amp;#39;; 这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。
  Caches &amp;amp; Buffers： 查询缓存组件
 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在不同客户端之间共享。 从MySQL 5.</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0-%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jiayi26.github.io/posts/%E7%AC%AC15%E7%AB%A0-%E9%94%81/</guid>
      <description>第15章 锁 1. 概述 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证。 锁冲突 也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。
2. MySQL并发事务访问相同记录 2.1 读-读情况 读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。
2.2 写-写情况 写-写情况，即并发事务相继对相同的记录做出改动。
在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。
2.3 读-写或写-读情况 读-写或写-读，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。
2.4 并发问题的解决方案 怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：
 方案一：读操作利用多版本并发控制（MVCC，下章讲解），写操作进行加锁。  所谓的MVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本（历史版本由undo日志构建）。查询语句只能读到在生成ReadView之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。
 普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。
 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象； 在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作 才会生成一个ReadView，之后的SELECT操作都复用这ReadView，这样也就避免了不可重复读和幻读的问题。     方案二：读、写操作都采用加锁的方式。
  小结对比发现：
 采用MVCC方式的话，读-写操作彼此并不冲突，性能更高。 采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。    一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。
3. 锁的不同角度分类 3.1 从数据操作的类型划分：读锁、写锁  读锁：也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。 写锁：也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。  需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。
1. 锁定读
在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式：
 对读取的记录加S锁：  SELECT ... LOCK IN SHARE MODE; # 或 SELECT .</description>
    </item>
    
  </channel>
</rss>
