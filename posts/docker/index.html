<!doctype html><html lang=en dir=auto><head><meta name="referrer" content="no-referrer"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker | JIAYI's Blog</title><meta name=keywords content="Docker"><meta name=description content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/posts/docker/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker"><meta property="og:description" content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><meta property="og:type" content="article"><meta property="og:url" content="https://jiayi26.github.io/posts/docker/"><meta property="article:section" content="posts"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiayi26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker","item":"https://jiayi26.github.io/posts/docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker","name":"Docker","description":"Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 \u0026ldquo;Build，Ship and Run Any App,Anywhere\u0026rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。\nDocker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。\n容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。\n虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。\n 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例\n卸载旧版本 [root@test_server ~]# yum remove docker \\ \u0026gt; docker-client \\ \u0026gt; docker-client-latest \\ \u0026gt; docker-common \\ \u0026gt; docker-latest \\ \u0026gt; docker-latest-logrotate \\ \u0026gt; docker-logrotate \\ \u0026gt; docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的","keywords":["Docker"],"articleBody":"Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 “Build，Ship and Run Any App,Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。\nDocker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。\n容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。\n虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。\n 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例\n卸载旧版本 [root@test_server ~]# yum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的\n#安装必要的一些系统工具 [root@test_server ~]# yum install -y yum-utils  #添加阿里云镜像仓库 [root@test_server ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  #更新yum软件包索引 [root@test_server ~]# yum makecache 安装启动Docker [root@test_server ~]# yum install -y docker-ce docker-ce-cli containerd.io [root@test_server ~]# systemctl start docker [root@test_server ~]# systemctl enable docker 验证 #查看版本 [root@test_server ~]# docker version  #hello-world [root@test_server ~]# docker run hello-world 卸载\n[root@test_server ~]# yum remove docker-ce docker-ce-cli containerd.io [root@test_server ~]# rm -rf /var/lib/docker [root@test_server ~]# rm -rf /var/lib/containerd 配置阿里云镜像加速 https://cr.console.aliyun.com/\n[root@test_server ~]# mkdir -p /etc/docker [root@test_server ~]# tee /etc/docker/daemon.json   {  \"registry-mirrors\": [\"你的加速器地址\"]  }  EOF  [root@test_server ~]# systemctl daemon-reload [root@test_server ~]# systemctl restart docker Docker常用命令 帮助类命令    命令 解释     docker –help 查看docker帮助文档   docker 具体命令 –help 查看docker具体命令帮助文档    镜像命令    命令 解释     docker images 查看本地的镜像   docker search 镜像名字 搜索镜像   docker pull 镜像名字 拉取镜像   docker rmi 镜像ID或名字 删除镜像   docker system df 查看镜像、容器、数据卷所占空间    容器命令    命令 解释     docker run 启动容器   docker ps 当前正在运行的容器   docker start 容器ID或容器名 启动已停止运行的容器   docker restart 容器ID或容器名 重启容器   docker stop 容器ID或容器名 停止容器   docker kill 容器ID或容器名 强制停止容器   docker rm 容器ID或容器名 删除已停止的容器   docker logs 容器ID 查看容器日志   docker top 容器ID 查看容器内进程   docker inspect 容器ID 查看容器内部细节   docker cp 容器ID:容器文件路径 目的主机路径 从容器内拷贝文件到目的主机   docker export 容器ID  文件名.tar 导出容器内容作为一个tar归档文件   cat 文件名.tar | docker import - 镜像名 导入镜像   docker exec -it 容器ID 进入容器（exit退出，容器不停止）   docker attach 容器ID 进入容器（exit退出，容器停止）    #docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] [root@test_server ~]# docker run -d -p 80:80 --name=mynginx nginx -i：交互式 -t：终端 -d：以后台的方式运行容器 -P：随机映射端口 -p：指定映射端口 --name=镜像名字：为容器指定一个名字 exit：退出容器，容器停止 ctrl+p+q：退出容器，容器不停止    命令 描述 解释     attach Attach to a running container 当前 shell 下 attach 连接指定运行镜像   build Build an image from a Dockerfile 通过 Dockerfile 定制镜像   commit Create a new image from a container changes 提交当前容器为新的镜像   cp Copy files/folders from the containers filesystem to the host path 从容器中拷贝指定文件或者目录到宿主机中   create Create a new container 创建一个新的容器，同 run，但不启动容器   diff Inspect changes on a container’s filesystem 查看 docker 容器变化   events Get real time events from the server 从 docker 服务获取容器实时事件   exec Run a command in an existing container 在已存在的容器上运行命令   export Stream the contents of a container as a tar archive 导出容器的内容流作为一个 tar 归档文件[对应 import ]   history Show the history of an image 展示一个镜像形成历史   images List images 列出系统当前镜像   import Create a new filesystem image from the contents of a tarball 从tar包中的内容创建一个新的文件系统映像[对应export]   info Display system-wide information 显示系统相关信息   inspect Return low-level information on a container 查看容器详细信息   kill Kill a running container kill 指定 docker 容器   load Load an image from a tar archive 从一个 tar 包中加载一个镜像[对应 save]   login Register or Login to the docker registry server 注册或者登陆一个 docker 源服务器   logout Log out from a Docker registry server 从当前 Docker registry 退出   logs Fetch the logs of a container 输出当前容器日志信息   port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT 查看映射端口对应的容器内部源端口   pause Pause all processes within a container 暂停容器   ps List containers 列出容器列表   pull Pull an image or a repository from the docker registry server 从docker镜像源服务器拉取指定镜像或者库镜像   push Push an image or a repository to the docker registry server 推送指定镜像或者库镜像至docker源服务器   restart Restart a running container 重启运行的容器   rm Remove one or more containers 移除一个或者多个容器   rmi Remove one or more images 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]   run Run a command in a new container 创建一个新的容器并运行一个命令   save Save an image to a tar archive 保存一个镜像为一个 tar 包[对应 load]   search Search for an image on the Docker Hub 在 docker hub 中搜索镜像   start Start a stopped containers 启动容器   stop Stop a running containers 停止容器   tag Tag an image into a repository 给源中镜像打标签   top Lookup the running processes of a container 查看容器中运行的进程信息   unpause Unpause a paused container 取消暂停容器   version Show the docker version information 查看 docker 版本号   wait Block until a container stops, then print its exit code 截取容器停止时的退出状态值    Docker镜像 什么是镜像 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。\nUnionFS（联合文件系统） Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\nDocker镜像加载原理 Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n本地镜像发布到阿里云 本地先生成一个镜像 #原始的ubuntu镜像是不带vim命令的，我们安装vim命令并commit新镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it ubuntu root@e01aa0b39f6b:/# vim a.txt bash: vim: command not found  root@e01aa0b39f6b:/# apt-get update root@e01aa0b39f6b:/# apt-get -y install vim  [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker commit -m=\"add cmd vim\" -a=\"jiayi\" e01aa0b39f6b myubuntu:1.1 sha256:b792ae050b8c53e1b02bf98fc547ddf3d4274788c1db15aa922fb872f358b387 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE myubuntu 1.1 b792ae050b8c 6 seconds ago 182MB ubuntu latest ba6acccedd29 17 months ago 72.8MB hello-world latest feb5d9fea6a5 17 months ago 13.3kB 推送本地镜像到阿里云 打开阿里云\n点击管理\n#登录阿里云Docker Registry [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker login --username=238y0 registry.cn-hangzhou.aliyuncs.com  #将镜像推送到Registry [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker tag b792ae050b8c registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker push registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 从阿里云拉取镜像到本地 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker pull registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 本地镜像发布到私有仓库 Harbor镜像仓库安装及使用 Harbor简介\nHarbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：\n  提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。\n  提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。\n  支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。\n  良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。\n  Harbor的安装\n先安装docker-compose\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# curl -L \"https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose  #给docker-compose添加执行权限 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# chmod +x /usr/local/bin/docker-compose [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker-compose -v Docker Compose version v2.16.0 下载Harbor的压缩包https://github.com/goharbor/harbor/releases\n#上传到linux服务器并解压 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# tar -zxf harbor-offline-installer-v1.10.17.tgz [root@iZbp162vx7bwpqiv8pmpdvZ ~]# mv harbor /opt/  #修改 harbor.yml，注释掉下面的四行 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# vi harbor.yml hostname: 192.168.66.102 port: 85 #https: # port: 443 # certificate: /your/certificate/path # private_key: /your/private/key/path  #安装harbor [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# ./prepare [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# ./install.sh  #启动harbor [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker-compose up -d 访问Harbor\n默认密码：Harbor12345\n新建项目、创建用户\n给私有项目分配用户\n 访客：对于指定项目拥有只读权限 开发人员：对于指定项目拥有读写权限 维护人员：对于指定项目拥有读写权限，创建 Webhooks 项目管理员：除了读写权限，同时拥有用户管理/镜像扫描等管理权限  把镜像上传到Harbor 把Harbor地址加入到Docker信任列表\n[root@iZbp162vx7bwpqiv8pmpdvZ harbor]# vi /etc/docker/daemon.json {  \"registry-mirrors\": [\"https://5wr347bg.mirror.aliyuncs.com\"]  \"insecure-registries\":[\"121.40.217.66:85\"] } [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# systemctl daemon-reload [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# systemctl restart docker 登录Harbor\n[root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE myubuntu 1.1 a558d68de60a 9 seconds ago 182MB  docker login -u 用户名 -p 密码 121.40.217.66:85  #给镜像打标签 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker tag a558d68de60a 121.40.217.66:85/ops/myubuntu:1.1  #推送镜像 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker push 121.40.217.66:85/ops/myubuntu:1.1 从Harbor上拉取镜像 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker pull 121.40.217.66:85/ops/myubuntu:1.1 Docker容器数据卷 数据卷是什么 数据卷（Data Volumes）是宿主机中的一个目录或文件，数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n为什么要用数据卷 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。\n数据卷的特点：\n 数据卷可在容器之间共享或重用数据 卷中的更改可以直接实时生效 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止  数据卷的基本使用 #创建数据卷 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume create mydata mydata  #列出所有数据卷 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume ls DRIVER VOLUME NAME local mydata  #查看数据卷信息 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume inspect mydata [  {  \"CreatedAt\": \"2023-03-14T16:36:47+08:00\",  \"Driver\": \"local\",  \"Labels\": null,  \"Mountpoint\": \"/var/lib/docker/volumes/mydata/_data\",  \"Name\": \"mydata\",  \"Options\": null,  \"Scope\": \"local\"  } ] 容器和宿主机之间数据共享\n用 docker run 启动一个容器\n-v :[:ro]\t#目录会自动创建\n:ro 此项为只读，不写此项默认为可读可写\n举例：\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it --name=u1 -v /tmp/hostdata:/tmp/dockerdata ubuntu  [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker ps -n2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8b2cd2892e82 ubuntu \"bash\" 35 minutes ago Up 18 minutes u1  #查看挂在目录 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker inspect 8b2cd2892e82 \"Mounts\": [  {  \"Type\": \"bind\",  \"Source\": \"/tmp/hostdata\",  \"Destination\": \"/tmp/dockerdata\",  \"Mode\": \"\",  \"RW\": true,  \"Propagation\": \"rprivate\"  } ], 把容器停掉，在宿主机的/tmp/hostdata目录下新建a.txt文件，重新启动容器后在容器的/tmp/dockerdata目录下能看到a.txt\n数据卷的继承\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it --name=u2 --volumes-from u1 ubuntu Docker安装部署中间件 安装tomcat #拉取镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker pull tomcat  #启动镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -d --name=t1 -p 8888:8080 tomcat  #tomcat8以上的版本需要把webapps.dist目录下的复制到webapps root@0c4129d634bc:/usr/local/tomcat# rm -rf webapps root@0c4129d634bc:/usr/local/tomcat# mv webapps.dist webapps 访问tomcat\n安装MySQL [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -d -p 3306:3306 --name mysql \\  -v /data/mysql/log:/var/log/mysql \\  -v /data/mysql/data:/var/lib/mysql \\  -v /data/mysql/conf:/etc/mysql/conf.d \\  -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7  #进入mysql容器登录mysql [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker exec -it mysql /bin/bash root@a6bfec31c594:/# mysql -uroot -p Enter password: mysql show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) Dockerfile Dockerfile的概述 Dockerfile 是一种被Docker程序解释的脚本，Dockerfile是由一条条的命令组成的，每条命令对应linux下面的一条命令，Docker程序将这些DockerFile指令再翻译成真正的linux命令，其有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docke镜像，避免了重复手动制作镜像的麻烦，类似与shell脚本一样，可以方便高效的制作镜像。\nDockerfile文件说明  每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写 使用 # 开始作为注释 每一行只支持一条指令，每条指令可以携带多个参数 指令按文件的顺序从上至下执行 每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令  Dockerfile指令介绍    指令 说明     FROM 指定基础镜像   LABEL 指定镜像元数据，如镜像作者   RUN 执行shell命令   COPY 拷贝文件和目录到镜像中   ADD 拷贝文件到镜像中，会自动处理URL和解压   ENV 设置环境变量   USER 指定镜像用什么用户去执行，不指定默认是root   WORKDIR 指定容器的工作目录   EXPOSE 暴露端口   VOLUME 数据卷，用作数据持久化   CMD 容器启动时执行的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被 docker run 之后的参数覆盖   ENTRYPOINT 容器启动时执行的命令。类似于CMD指令，不会被 docker run 之后的参数覆盖，而且这些命令行参数会被当作参数传给 ENTRYPOINT    自定义镜像 Dockerfile 制作基于基础镜像的Base镜像\n[root@iZbp162vx7bwpqiv8pmpdvZ ubuntu]# pwd /data/dockerfile/os/ubuntu [root@iZbp162vx7bwpqiv8pmpdvZ ubuntu]# vim Dockerfile FROM ubuntu:latest  LABEL maintainer=\"jiayi\"  RUN apt-get update \u0026\u0026 apt-get install -y vim net-tools make gcc libpcre3-dev zlib1g zlib1g-dev  [root@iZbp162vx7bwpqiv8pmpdvZ ubuntu]# docker build -t ubuntu:v1.0 . [root@iZbp162vx7bwpqiv8pmpdvZ ubuntu]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu v1.0 73e67d988202 5 minutes ago 343MB Dockerfile 制作基于Base镜像的 nginx 镜像\n[root@iZbp162vx7bwpqiv8pmpdvZ nginx]# pwd /data/dockerfile/web/nginx [root@iZbp162vx7bwpqiv8pmpdvZ nginx]# vim Dockerfile FROM ubuntu:v1.0  LABEL maintainer=\"jiayi\"  ENV nginx_version nginx-1.23.3  WORKDIR /usr/local/src/  ADD $nginx_version.tar.gz /usr/local/src  RUN cd /usr/local/src/$nginx_version \\  \u0026\u0026 ./configure --prefix=/usr/local/nginx \\  \u0026\u0026 make \u0026\u0026 make install \\  \u0026\u0026 useradd -s /sbin/nologin nginx  COPY index.html /usr/local/nginx/html  VOLUME /usr/local/nginx/html  ENV PATH $PATH:/usr/local/nginx/sbin  EXPOSE 80  ENTRYPOINT [\"nginx\"]  CMD [\"-g\",\"daemon off;\"]  [root@iZbp162vx7bwpqiv8pmpdvZ nginx]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE nginx-ubuntu v1.23 a816e1d5d4c6 3 minutes ago 373MB  [root@iZbp162vx7bwpqiv8pmpdvZ nginx]# docker run -d -p 80:80 nginx-ubuntu:v1.23  46cebc2fe19f8658ec4e1038fa53a979fcfeb353769b787d177be3a5c931fe4a [root@iZbp162vx7bwpqiv8pmpdvZ nginx]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 46cebc2fe19f nginx-ubuntu:v1.23 \"nginx -g 'daemon of…\" 3 seconds ago Up 2 seconds 0.0.0.0:80-80/tcp, :::80-80/tcp tender_goldberg 访问nginx\nDocker网络 Docker启动后，会在每个宿主机会生成一个名称为docker0的网卡其IP地址是172.17.0.1/16\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# ifconfig |grep docker0 -A 8 docker0: flags=4099 mtu 1500  inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255  inet6 fe80::42:e7ff:fec0:1362 prefixlen 64 scopeid 0x20  ether 02:42:e7:c0:13:62 txqueuelen 0 (Ethernet)  RX packets 341435 bytes 20873036 (19.9 MiB)  RX errors 0 dropped 0 overruns 0 frame 0  TX packets 362121 bytes 994179024 (948.1 MiB)  TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Docker的四种网络模式\n#列出docker网络 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE fd6c253f44cc bridge bridge local 0a363a698c42 harbor_harbor bridge local 3092b903331f host host local fe599c88bd45 none null local  #查看docker网络 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker inspect host  #创建docker网络 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker network create mynet  #删除docker网络 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker network rm mynet bridge：Docker的默认网络模式，为容器分配IP，并将容器连接到docker0。\nhost：容器和宿主机共享 Network Namespace。\nnone：容器有独立的 Network Namespace，但并没有对他进行网络设置。\ncontainer：容器和另外一个容器共享 Network Namespace。\nDocker-compose容器编排 什么是docker-compose docker-compose 项目是Docker 官方的开源项目，负责实现对Docker 容器集群的快速编排，docker-compose 将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。\n当在宿主机启动较多的容器时候，如果都是手动操作会觉得比较麻烦而且容易出错，docker-compose 是 docker 容器的一种编排服务，一个管理多个容器的工具。\n可以解决容器之间的依赖关系，就像启动一个nginx 前端服务的时候会调用后端的tomcat，那就得先启动tomcat，但是启动tomcat 容器还需要依赖数据库，那就还得先启动数据库，docker-compose 可以用来解决这样的嵌套依赖关系，并且可以替代docker命令对容器进行创建、启动和停止等手工的操作。\n如果说docker命令就像linux的命令，docker-compse就像shell脚本，可以自动的执行容器批量操作，从而实现自动化的容器管理，或者说docker命令相当于ansible命令，那么docker-compose文件，就相当于ansible-playbook的yaml文件。\ndocker-compose的安装 前面在讲本地镜像发布到Harbor的时候有安装过\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# curl -L \"https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose  #给docker-compose添加执行权限 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# chmod +x /usr/local/bin/docker-compose [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker-compose -v Docker Compose version v2.16.0 命令选项概述 docker-compose --help Define and run multi-container applications with Docker. Usage:  docker-compose [-f ...] [options] [COMMAND] [ARGS...]  docker-compose -h|--help  #选项说明： -f，–file FILE #指定Compose 模板文件，默认为docker-compose.yml。 -p，–project-name NAME #指定项目名称，默认将使用当前所在目录名称作为项目名。 --verbose #显示更多输出信息 --log-level LEVEL #定义日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)  --no-ansi #不显示ANSI 控制字符 -v, --version #显示版本  #以下为命令选项，需要在docker-compose.yml|yaml 文件所在在目录里执行  build #构建镜像  bundle #从当前docker compose 文件生成一个以为名称的json格式的Docker Bundle 备份文件 config -q #查看当前配置，没有错误不输出任何信息  create #创建服务 down #停止和删除所有容器、网络、镜像和卷  #events #从容器接收实时事件，可以指定json 日志格式，较少使用  exec #进入指定容器进行操作  help #显示帮助细信息  images #显示镜像信息 kill #强制终止运行中的容器  logs #查看容器的日志  pause #暂停服务  port #查看端口  ps #列出容器 pull #重新拉取镜像，镜像发生变化后，需要重新拉取镜像 push #上传镜像  restart #重启服务  rm #删除已经停止的服务  run #一次性运行容器  scale #设置指定服务运行的容器个数  start #启动服务 stop #停止服务  top #显示容器运行状态  unpause #取消暂定  up #创建并启动容器 docker-compose文件是一个yaml格式的文件，默认docker-compose命令会调用当前目录下的docker-compose.yml的文件，因此一般执行docker-compose命令前先进入docker-compose.yml文件所在目录。\n搭建wordpress [root@iZbp162vx7bwpqiv8pmpdvZ blog]# vim compose.yml services:  wordpress:  image: wordpress:latest  ports:  - \"8000:80\"  volumes:  - wordpress_data:/var/www/html  restart: always  depends_on:  - db  environment:  WORDPRESS_DB_HOST: db:3306  WORDPRESS_DB_USER: wordpress  WORDPRESS_DB_PASSWORD: wordpress  WORDPRESS_DB_NAME: wordpress   db:  image: mysql:5.7  ports:  - \"3306:3306\"  volumes:  - db_data:/var/lib/mysql  restart: always  environment:  MYSQL_ROOT_PASSWORD: 123456  MYSQL_DATABASE: wordpress  MYSQL_USER: wordpress  MYSQL_PASSWORD: wordpress  volumes:  db_data:  wordpress_data:  #检查语法，加 -q 没有错误的话不会输出 [root@iZbp162vx7bwpqiv8pmpdvZ blog]# docker-compose config  #启动容器，可以看到启动过程，加 -d 后台运行 [root@iZbp162vx7bwpqiv8pmpdvZ blog]# docker-compose up 访问wordpress\n可视化工具Portainer Portainer 是一个通用的容器管理平台，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。\n安装Portainer [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -d -p 8100:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest 访问Portainer ，创建用户\n点击看板Dashboard，可以看到详细信息\nDocker Swarm 什么是Docker Swarm Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在https://github.com/docker/swarm， 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的DockerClient(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。\nDocker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。\nSwarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。\nDocker Swarm的架构 Swarm是典型的master-slave结构，通过发现服务来选举manager。Docker Client使用Swarm对 集群(Cluster)进行调度使用。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持。\nSwarm的几个关键概念 Swarm：集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm\nNode：分为管理 (manager) 节点和工作 (worker) 节点。\nmanager节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。通常，第一个启用docker swarm的节点将成为leader，后来加入的都是follower。当前的leader如果挂掉，剩余的节点将重新选举出一个新的leader。每一个manager都有一个完整的当前集群状态的副本，可以保证manager的高可用。\nworker节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。worker节点之间，通过control plane进行通信，这种通信使用gossip协议，并且是异步的。\nServices：指一组任务的集合，服务定义了任务的属性。服务有两种模式：\nreplicated services：按照一定规则在各个工作节点上运行指定个数的任务。\nglobal services：每个工作节点上运行一个任务\nTask：任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点。\nSwarm的调度策略 Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：Spread，Binpack，Random。\nSpread：Spread策略会选择运行容器最少的那台节点来运行新的容器，使得容器会均衡的分布在集群中的各个节点上运行\nBinpack：Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在一个节点上面。\nRandom：随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运行的容器的数量来计算应该运行容器的节点。\nSwarm Cluster模式特性 批量创建服务：建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式\n强大的集群的容错性：当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值–replicas n，在集群中剩余的空闲节点上，重新拉起容器副本，整个副本迁移的过程无需人工干预。\n服务节点的可扩展性：Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale参数即可复制出新的副本出来。\n调度机制：所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。\nDcoker Swarm 集群部署 docker swarm 命令\n[root@manager01 ~]# docker swarm --help Usage: docker swarm COMMAND  Manage Swarm  Commands:  ca Display and rotate the root CA  init Initialize a swarm  join Join a swarm as a node and/or manager  join-token Manage join tokens  leave Leave the swarm  unlock Unlock swarm  unlock-key Manage the unlock key  update Update the swarm  Run 'docker swarm COMMAND --help' for more information on a command.  [root@manager01 ~]# docker node --help Usage: docker node COMMAND  Manage Swarm nodes  Commands:  demote Demote one or more nodes from manager in the swarm  inspect Display detailed information on one or more nodes  ls List nodes in the swarm  promote Promote one or more nodes to manager in the swarm  ps List tasks running on one or more nodes, defaults to current node  rm Remove one or more nodes from the swarm  update Update a node  Run 'docker service COMMAND --help' for more information on a command.  [root@manager01 ~]# docker service --help Usage: docker service COMMAND  Manage services  Commands:  create Create a new service  inspect Display detailed information on one or more services  logs Fetch the logs of a service or task  ls List services  ps List the tasks of one or more services  rm Remove one or more services  rollback Revert changes to a service's configuration scale Scale one or multiple replicated services update Update a service Run 'docker service COMMAND --help' for more information on a command. #创建Swarm集群 [root@manager01 ~]# docker swarm init --advertise-addr 192.168.31.48 Swarm initialized: current node (lzhsbmrqtpg96gwlw193xes35) is now a manager.  To add a worker to this swarm, run the following command:   docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377  To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.  #上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。其中，--advertise-addr参数表示其它swarm中的worker节点使用此ip地址与manager联系。命令的输出包含了其它节点如何加入集群的命令。  #查看Swarm状态 [root@manager01 ~]# docker info |grep -i swarm  Swarm: active  #查看Swarm节点信息 [root@manager01 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION lzhsbmrqtpg96gwlw193xes35 * manager01 Ready Active Leader 20.10.16  #添加节点主机到Swarm集群：分别在node01和node02上操作 [root@node01 ~]# docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377 This node joined a swarm as a worker.  [root@node02 ~]# docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377 This node joined a swarm as a worker.  #再次查看Swarm节点信息 [root@manager01 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION lzhsbmrqtpg96gwlw193xes35 * manager01 Ready Active Leader 20.10.16 jjl18ughg79ht0jbf7xiuzfdq node01 Ready Active 23.0.1 16ypcv81ozwxiruechzrvjye5 node02 Ready Active 23.0.1  #把node02节点的AVAILABILITY设置为Drain [root@manager01 ~]# docker node update --availability drain node02 node02 [root@manager01 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION lzhsbmrqtpg96gwlw193xes35 * manager01 Ready Active Leader 20.10.16 jjl18ughg79ht0jbf7xiuzfdq node01 Ready Active 23.0.1 16ypcv81ozwxiruechzrvjye5 node02 Ready Drain 23.0.1  #把node02节点的AVAILABILITY设置为Active [root@manager01 ~]# docker node update --availability active node02 node02 [root@manager01 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION lzhsbmrqtpg96gwlw193xes35 * manager01 Ready Active Leader 20.10.16 jjl18ughg79ht0jbf7xiuzfdq node01 Ready Active 23.0.1 16ypcv81ozwxiruechzrvjye5 node02 Ready Active 23.0.1  swarm集群中node的 AVAILABILITY 状态可以为 Active，Drain，Pause。\nActive：node可以接受来自manager节点的任务分派\nDrain：node节点会结束现有task并将其调度到其他节点，且不再接受来自manager节点的任务分派\nPause：manager节点不会把任务分派给node节点，但现有task会继续运行\n 在Swarm中部署nginx #创建网络 [root@manager01 ~]# docker network create -d overlay nginx 1s1t6r59c0pplpd32kkznthb0 [root@manager01 ~]# docker network ls |grep nginx 1s1t6r59c0pp nginx overlay swarm  #创建一个具有一个副本（--replicas=1）的nginx服务 [root@manager01 ~]# docker service create --name=mynginx --replicas=1 --network=nginx -p 80:80 nginx  yuoo1c8gm631xxx6ve3zyld6n overall progress: 1 out of 1 tasks 1/1: running [==================================================] verify: Service converged  #查看服务列表 [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS yuoo1c8gm631 mynginx replicated 1/1 nginx:latest *:80-80/tcp  #查询swarm中服务的信息 [root@manager01 ~]# docker service inspect --pretty mynginx ID:\tyuoo1c8gm631xxx6ve3zyld6n Name:\tmynginx Service Mode:\tReplicated  Replicas:\t1 Placement: UpdateConfig:  Parallelism:\t1  On failure:\tpause  Monitoring Period: 5s  Max failure ratio: 0  Update order: stop-first RollbackConfig:  Parallelism:\t1  On failure:\tpause  Monitoring Period: 5s  Max failure ratio: 0  Rollback order: stop-first ContainerSpec:  Image:\tnginx:latest@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31  Init:\tfalse Resources: Networks: nginx Endpoint Mode:\tvip Ports:  PublishedPort = 80  Protocol = tcp  TargetPort = 80  PublishMode = ingress  #查询mynginx服务在哪个节点运行 [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS jcp8a0kg2m4p mynginx.1 nginx:latest manager01 Running Running 6 minutes ago  #在manager01的节点可以看到nginx容器正在运行 [root@manager01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES afafbe099b69 nginx:latest \"/docker-entrypoint.…\" 7 minutes ago Up 7 minutes 80/tcp mynginx.1.jcp8a0kg2m4p7ejy3v9p55zlp 在Swarm的动态扩容(scale)\n#将mynginx服务动态扩展到4个 [root@manager01 ~]# docker service scale mynginx=4 mynginx scaled to 4 overall progress: 4 out of 4 tasks 1/4: running [==================================================] 2/4: running [==================================================] 3/4: running [==================================================] 4/4: running [==================================================] verify: Service converged  #查看服务列表和运行节点 [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS yuoo1c8gm631 mynginx replicated 4/4 nginx:latest *:80-80/tcp  [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS jcp8a0kg2m4p mynginx.1 nginx:latest manager01 Running Running 12 minutes ago opvyk40r2v7t mynginx.2 nginx:latest node02 Running Running 44 seconds ago mwonwvdb3hq6 mynginx.3 nginx:latest node02 Running Running 44 seconds ago i4l00g7nhsl7 mynginx.4 nginx:latest node01 Running Running 45 seconds ago 模拟node02节点宕机\n如果一个节点宕机了（即该节点就会从swarm集群中被踢出），Docker会将在该节点运行的容器，调度到其他节点，以满足指定数量的副本（replicas）保持运行状态。\n#停掉node02的docker服务 [root@node02 ~]# systemctl stop docker  [root@manager01 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION lzhsbmrqtpg96gwlw193xes35 * manager01 Ready Active Leader 20.10.16 jjl18ughg79ht0jbf7xiuzfdq node01 Ready Active 23.0.1 16ypcv81ozwxiruechzrvjye5 node02 Down Active 23.0.1  #可以看到node02上的task实例已经转移到别的节点上了 [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS yuoo1c8gm631 mynginx replicated 6/4 nginx:latest *:80-80/tcp [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS jcp8a0kg2m4p mynginx.1 nginx:latest manager01 Running Running 20 minutes ago 93di7mqaug77 mynginx.2 nginx:latest node01 Running Running 14 seconds ago opvyk40r2v7t \\_ mynginx.2 nginx:latest node02 Shutdown Running 8 minutes ago iszkb164456y mynginx.3 nginx:latest manager01 Running Running 14 seconds ago mwonwvdb3hq6 \\_ mynginx.3 nginx:latest node02 Shutdown Running 8 minutes ago i4l00g7nhsl7 mynginx.4 nginx:latest node01 Running Running 8 minutes ago  [root@manager01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f03222f6428b nginx:latest \"/docker-entrypoint.…\" 3 minutes ago Up 3 minutes 80/tcp mynginx.3.iszkb164456y0exea29uiqxwx afafbe099b69 nginx:latest \"/docker-entrypoint.…\" 23 minutes ago Up 23 minutes 80/tcp mynginx.1.jcp8a0kg2m4p7ejy3v9p55zlp  [root@node01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1ed4ee89030b nginx:latest \"/docker-entrypoint.…\" 3 minutes ago Up 3 minutes 80/tcp mynginx.2.93di7mqaug7798528qz1nlixl 71b69284f5ef nginx:latest \"/docker-entrypoint.…\" 11 minutes ago Up 11 minutes 80/tcp mynginx.4.i4l00g7nhsl7ka1w3l6be8zgy 在Swarm的动态缩容(scale)\n#将mynginx服务动态缩容到4个 [root@manager01 ~]# docker service scale mynginx=1 mynginx scaled to 1 overall progress: 1 out of 1 tasks 1/1: running [==================================================] verify: Service converged  #查看服务列表和运行节点 [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS yuoo1c8gm631 mynginx replicated 1/1 nginx:latest *:80-80/tcp [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS jcp8a0kg2m4p mynginx.1 nginx:latest manager01 Running Running 30 minutes ago opvyk40r2v7t mynginx.2 nginx:latest node02 Shutdown Shutdown 2 minutes ago mwonwvdb3hq6 mynginx.3 nginx:latest node02 Shutdown Shutdown 2 minutes ago  #登录node节点查看已经没有nginx在运行了 [root@node01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  [root@node02 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 除了上面使用scale进行容器的扩容或缩容之外，还可以使用docker service update 命令。 可对服务的启动参数 进行更新/修改。\n[root@manager01 ~]# docker service update --replicas=3 mynginx mynginx overall progress: 3 out of 3 tasks 1/3: running [==================================================] 2/3: running [==================================================] 3/3: running [==================================================] verify: Service converged  [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS yuoo1c8gm631 mynginx replicated 3/3 nginx:latest *:80-80/tcp  [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS jcp8a0kg2m4p mynginx.1 nginx:latest manager01 Running Running 38 minutes ago h9kouj0noeed mynginx.2 nginx:latest node01 Running Running 15 seconds ago opvyk40r2v7t \\_ mynginx.2 nginx:latest node02 Shutdown Shutdown 9 minutes ago mxbe15gl0000 mynginx.3 nginx:latest node02 Running Running 14 seconds ago mwonwvdb3hq6 \\_ mynginx.3 nginx:latest node02 Shutdown Shutdown 9 minutes ago 在Swarm中使用volume #为了方便把前面的mynginx服务删掉 [root@manager01 ~]# docker service rm mynginx mynginx [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS  #创建volume [root@manager01 ~]# docker volume create nginx_data nginx_data  #查看volume详情 [root@manager01 ~]# docker volume inspect nginx_data [  {  \"CreatedAt\": \"2023-03-16T16:08:21+08:00\",  \"Driver\": \"local\",  \"Labels\": {},  \"Mountpoint\": \"/var/lib/docker/volumes/nginx_data/_data\",  \"Name\": \"nginx_data\",  \"Options\": {},  \"Scope\": \"local\"  } ] 部署nginx服务并挂载nginx_data\n[root@manager01 ~]# docker service create --name=mynginx --replicas=3 --mount type=volume,src=nginx_data,dst=/data nginx jxft6qg4w09znm7yyl7z98tgv overall progress: 3 out of 3 tasks 1/3: running [==================================================] 2/3: running [==================================================] 3/3: running [==================================================] verify: Service converged  #查看服务列表和运行节点 [root@manager01 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS jxft6qg4w09z mynginx replicated 3/3 nginx:latest [root@manager01 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS iqgz3ddomq4c mynginx.1 nginx:latest node01 Running Running 21 seconds ago eo54f0022ghj mynginx.2 nginx:latest node02 Running Running 21 seconds ago pde6k6qzik5g mynginx.3 nginx:latest manager01 Running Running 21 seconds ago 多服务Swarm集群部署 docker service部署的是单个服务，可以使用docker stack进行多服务编排部署\n我们这里部署三个服务（Nginx，Visualizer，Portainer）\n#编写docker-compose.yml [root@manager01 swarm]# vim docker-compose.yml version: \"3\" services:  web:  image: nginx  ports:  - \"8088:80\"  deploy:  mode: replicated  replicas: 3   visualize:  image: dockersamples/visualizer  ports:  - \"8080:8080\"  volumes:  - \"/var/run/docker.sock:/var/run/docker.sock\"  deploy:  replicas: 1  placement:  constraints: [node.role == manager]   portainer:  image: portainer/portainer  ports:  - \"9000:9000\"  volumes:  - \"/var/run/docker.sock:/var/run/docker.sock\"  environment:  - TZ=Asia/Shanghai  deploy:  replicas: 1  placement:  constraints: [node.role == manager]  #查看服务列表和运行节点 [root@manager01 swarm]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS ypgunrzwoh7o nvp_portainer replicated 1/1 portainer/portainer:latest *:9000-9000/tcp ksyai2lpcq8s nvp_visualize replicated 1/1 dockersamples/visualizer:latest *:8080-8080/tcp k6h4attw960j nvp_web replicated 3/3 nginx:latest *:8088-80/tcp  [root@manager01 swarm]# docker service ps nvp_portainer ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS bvvxgdz08364 nvp_portainer.1 portainer/portainer:latest manager01 Running Running about a minute ago  [root@manager01 swarm]# docker service ps nvp_visualize ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 0b40xkse08na nvp_visualize.1 dockersamples/visualizer:latest manager01 Running Running about a minute ago  [root@manager01 swarm]# docker service ps nvp_web ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS c2jbbwjc2tui nvp_web.1 nginx:latest manager01 Running Running 2 minutes ago ue1wjtxcc8y7 nvp_web.2 nginx:latest node01 Running Running 2 minutes ago x674wr3gmk5b nvp_web.3 nginx:latest node02 Running Running 2 minutes ago 验证\n访问http://192.168.31.48:8080/\n访问http://192.168.31.48:9000/\n","wordCount":"3332","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiayi26.github.io/posts/docker/"},"publisher":{"@type":"Organization","name":"JIAYI's Blog","logo":{"@type":"ImageObject","url":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiayi26.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiayi26.github.io/posts/>Posts</a></div><h1 class=post-title>Docker</h1><div class=post-meta>16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Pass-JIAYI%27s.github.io/post/posts/docker.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=docker的概述>Docker的概述<a hidden class=anchor aria-hidden=true href=#docker的概述>#</a></h3><h4 id=什么是docker>什么是Docker<a hidden class=anchor aria-hidden=true href=#什么是docker>#</a></h4><ul><li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。</li><li>Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。</li><li>Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。</li></ul><h4 id=docker的主要目标>Docker的主要目标<a hidden class=anchor aria-hidden=true href=#docker的主要目标>#</a></h4><p><strong>&ldquo;Build，Ship and Run Any App,Anywhere&rdquo;</strong>，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。</p><h4 id=docker的组成>Docker的组成<a hidden class=anchor aria-hidden=true href=#docker的组成>#</a></h4><ul><li><strong>镜像(Images)</strong>：镜像可以理解为创建实例使用的模板</li><li><strong>容器(Container)</strong>: 容器是从镜像生成对外提供服务的一个或一组服务</li><li><strong>仓库(Registry)</strong>: 保存镜像的仓库，官方仓库: <a href=https://hub.docker.com/>https://hub.docker.com/</a>
<img loading=lazy src=http://www.yunweipai.com/wp-content/uploads/2020/06/engine-components-flow.png alt=logo></li></ul><h4 id=容器和虚拟机的比较>容器和虚拟机的比较<a hidden class=anchor aria-hidden=true href=#容器和虚拟机的比较>#</a></h4><p>容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。</p><p><strong>容器</strong>是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。</p><p><strong>虚拟机</strong> (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。</p><ul><li>资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机</li><li>开销更小：不需要启动单独的虚拟机OS内核占用硬件资源</li><li>启动速度更快：可以在数秒内完成启动</li><li>集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理
<img loading=lazy src=https://www.docker.com/wp-content/uploads/2021/11/docker-containerized-appliction-blue-border_2.png.webp alt=logo>
<img loading=lazy src=https://www.docker.com/wp-content/uploads/2021/11/container-vm-whatcontainer_2.png.webp alt=logo></li></ul><h3 id=docker的安装>Docker的安装<a hidden class=anchor aria-hidden=true href=#docker的安装>#</a></h3><p>官方文档：<a href=https://docs.docker.com/engine/install/centos/>https://docs.docker.com/engine/install/centos/</a>
这里以CentOS7为例</p><h4 id=卸载旧版本>卸载旧版本<a hidden class=anchor aria-hidden=true href=#卸载旧版本>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum remove docker \</span>
</span></span><span style=display:flex><span>&gt;              docker-client <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-client-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-common <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-latest-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-engine
</span></span></code></pre></div><h4 id=设置镜像仓库>设置镜像仓库<a hidden class=anchor aria-hidden=true href=#设置镜像仓库>#</a></h4><p>由于官网的yum源太慢，下面把镜像仓库设置成阿里云的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#安装必要的一些系统工具</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum install -y yum-utils</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#添加阿里云镜像仓库</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#更新yum软件包索引</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum makecache</span>
</span></span></code></pre></div><h4 id=安装启动docker>安装启动Docker<a hidden class=anchor aria-hidden=true href=#安装启动docker>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum install -y docker-ce docker-ce-cli containerd.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl start docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl enable docker</span>
</span></span></code></pre></div><h4 id=验证>验证<a hidden class=anchor aria-hidden=true href=#验证>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#查看版本</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker version</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#hello-world</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run hello-world</span>
</span></span></code></pre></div><p><strong>卸载</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum remove docker-ce docker-ce-cli containerd.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># rm -rf /var/lib/docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># rm -rf /var/lib/containerd</span>
</span></span></code></pre></div><h4 id=配置阿里云镜像加速>配置阿里云镜像加速<a hidden class=anchor aria-hidden=true href=#配置阿里云镜像加速>#</a></h4><p><a href=https://cr.console.aliyun.com/>https://cr.console.aliyun.com/</a></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230313170820052.png alt=image-20230313170820052></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># mkdir -p /etc/docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>&gt;   <span style=color:#e6db74>&#34;registry-mirrors&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;你的加速器地址&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>&gt; EOF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl daemon-reload</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl restart docker</span>
</span></span></code></pre></div><h3 id=docker常用命令>Docker常用命令<a hidden class=anchor aria-hidden=true href=#docker常用命令>#</a></h3><h4 id=帮助类命令>帮助类命令<a hidden class=anchor aria-hidden=true href=#帮助类命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker &ndash;help</td><td>查看docker帮助文档</td></tr><tr><td>docker 具体命令 &ndash;help</td><td>查看docker具体命令帮助文档</td></tr></tbody></table><h4 id=镜像命令>镜像命令<a hidden class=anchor aria-hidden=true href=#镜像命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker images</td><td>查看本地的镜像</td></tr><tr><td>docker search 镜像名字</td><td>搜索镜像</td></tr><tr><td>docker pull 镜像名字</td><td>拉取镜像</td></tr><tr><td>docker rmi 镜像ID或名字</td><td>删除镜像</td></tr><tr><td>docker system df</td><td>查看镜像、容器、数据卷所占空间</td></tr></tbody></table><h4 id=容器命令>容器命令<a hidden class=anchor aria-hidden=true href=#容器命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker run</td><td>启动容器</td></tr><tr><td>docker ps</td><td>当前正在运行的容器</td></tr><tr><td>docker start 容器ID或容器名</td><td>启动已停止运行的容器</td></tr><tr><td>docker restart 容器ID或容器名</td><td>重启容器</td></tr><tr><td>docker stop 容器ID或容器名</td><td>停止容器</td></tr><tr><td>docker kill 容器ID或容器名</td><td>强制停止容器</td></tr><tr><td>docker rm 容器ID或容器名</td><td>删除已停止的容器</td></tr><tr><td>docker logs 容器ID</td><td>查看容器日志</td></tr><tr><td>docker top 容器ID</td><td>查看容器内进程</td></tr><tr><td>docker inspect 容器ID</td><td>查看容器内部细节</td></tr><tr><td>docker cp 容器ID:容器文件路径 目的主机路径</td><td>从容器内拷贝文件到目的主机</td></tr><tr><td>docker export 容器ID > 文件名.tar</td><td>导出容器内容作为一个tar归档文件</td></tr><tr><td>cat 文件名.tar | docker import - 镜像名</td><td>导入镜像</td></tr><tr><td>docker exec -it 容器ID</td><td>进入容器（exit退出，容器不停止）</td></tr><tr><td>docker attach 容器ID</td><td>进入容器（exit退出，容器停止）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 80:80 --name=mynginx  nginx</span>
</span></span><span style=display:flex><span>-i：交互式
</span></span><span style=display:flex><span>-t：终端
</span></span><span style=display:flex><span>-d：以后台的方式运行容器
</span></span><span style=display:flex><span>-P：随机映射端口
</span></span><span style=display:flex><span>-p：指定映射端口
</span></span><span style=display:flex><span>--name<span style=color:#f92672>=</span>镜像名字：为容器指定一个名字
</span></span><span style=display:flex><span>exit：退出容器，容器停止
</span></span><span style=display:flex><span>ctrl+p+q：退出容器，容器不停止
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230313200613055.png alt=image-20230313200613055></p><table><thead><tr><th>命令</th><th>描述</th><th>解释</th></tr></thead><tbody><tr><td>attach</td><td>Attach to a running container</td><td>当前 shell 下 attach 连接指定运行镜像</td></tr><tr><td>build</td><td>Build an image from a Dockerfile</td><td>通过 Dockerfile 定制镜像</td></tr><tr><td>commit</td><td>Create a new image from a container changes</td><td>提交当前容器为新的镜像</td></tr><tr><td>cp</td><td>Copy files/folders from the containers filesystem to the host path</td><td>从容器中拷贝指定文件或者目录到宿主机中</td></tr><tr><td>create</td><td>Create a new container</td><td>创建一个新的容器，同 run，但不启动容器</td></tr><tr><td>diff</td><td>Inspect changes on a container&rsquo;s filesystem</td><td>查看 docker 容器变化</td></tr><tr><td>events</td><td>Get real time events from the server</td><td>从 docker 服务获取容器实时事件</td></tr><tr><td>exec</td><td>Run a command in an existing container</td><td>在已存在的容器上运行命令</td></tr><tr><td>export</td><td>Stream the contents of a container as a tar archive</td><td>导出容器的内容流作为一个 tar 归档文件[对应 import ]</td></tr><tr><td>history</td><td>Show the history of an image</td><td>展示一个镜像形成历史</td></tr><tr><td>images</td><td>List images</td><td>列出系统当前镜像</td></tr><tr><td>import</td><td>Create a new filesystem image from the contents of a tarball</td><td>从tar包中的内容创建一个新的文件系统映像[对应export]</td></tr><tr><td>info</td><td>Display system-wide information</td><td>显示系统相关信息</td></tr><tr><td>inspect</td><td>Return low-level information on a container</td><td>查看容器详细信息</td></tr><tr><td>kill</td><td>Kill a running container</td><td>kill 指定 docker 容器</td></tr><tr><td>load</td><td>Load an image from a tar archive</td><td>从一个 tar 包中加载一个镜像[对应 save]</td></tr><tr><td>login</td><td>Register or Login to the docker registry server</td><td>注册或者登陆一个 docker 源服务器</td></tr><tr><td>logout</td><td>Log out from a Docker registry server</td><td>从当前 Docker registry 退出</td></tr><tr><td>logs</td><td>Fetch the logs of a container</td><td>输出当前容器日志信息</td></tr><tr><td>port</td><td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td><td>查看映射端口对应的容器内部源端口</td></tr><tr><td>pause</td><td>Pause all processes within a container</td><td>暂停容器</td></tr><tr><td>ps</td><td>List containers</td><td>列出容器列表</td></tr><tr><td>pull</td><td>Pull an image or a repository from the docker registry server</td><td>从docker镜像源服务器拉取指定镜像或者库镜像</td></tr><tr><td>push</td><td>Push an image or a repository to the docker registry server</td><td>推送指定镜像或者库镜像至docker源服务器</td></tr><tr><td>restart</td><td>Restart a running container</td><td>重启运行的容器</td></tr><tr><td>rm</td><td>Remove one or more containers</td><td>移除一个或者多个容器</td></tr><tr><td>rmi</td><td>Remove one or more images</td><td>移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td></tr><tr><td>run</td><td>Run a command in a new container</td><td>创建一个新的容器并运行一个命令</td></tr><tr><td>save</td><td>Save an image to a tar archive</td><td>保存一个镜像为一个 tar 包[对应 load]</td></tr><tr><td>search</td><td>Search for an image on the Docker Hub</td><td>在 docker hub 中搜索镜像</td></tr><tr><td>start</td><td>Start a stopped containers</td><td>启动容器</td></tr><tr><td>stop</td><td>Stop a running containers</td><td>停止容器</td></tr><tr><td>tag</td><td>Tag an image into a repository</td><td>给源中镜像打标签</td></tr><tr><td>top</td><td>Lookup the running processes of a container</td><td>查看容器中运行的进程信息</td></tr><tr><td>unpause</td><td>Unpause a paused container</td><td>取消暂停容器</td></tr><tr><td>version</td><td>Show the docker version information</td><td>查看 docker 版本号</td></tr><tr><td>wait</td><td>Block until a container stops, then print its exit code</td><td>截取容器停止时的退出状态值</td></tr></tbody></table><h3 id=docker镜像>Docker镜像<a hidden class=anchor aria-hidden=true href=#docker镜像>#</a></h3><h4 id=什么是镜像>什么是镜像<a hidden class=anchor aria-hidden=true href=#什么是镜像>#</a></h4><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><h4 id=unionfs联合文件系统>UnionFS（联合文件系统）<a hidden class=anchor aria-hidden=true href=#unionfs联合文件系统>#</a></h4><p>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h4 id=docker镜像加载原理>Docker镜像加载原理<a hidden class=anchor aria-hidden=true href=#docker镜像加载原理>#</a></h4><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/55fc2729cfa3ad893c1d33b3e616645f.png alt=img></p><h3 id=本地镜像发布到阿里云>本地镜像发布到阿里云<a hidden class=anchor aria-hidden=true href=#本地镜像发布到阿里云>#</a></h3><h4 id=本地先生成一个镜像>本地先生成一个镜像<a hidden class=anchor aria-hidden=true href=#本地先生成一个镜像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#原始的ubuntu镜像是不带vim命令的，我们安装vim命令并commit新镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it ubuntu</span>
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# vim a.txt
</span></span><span style=display:flex><span>bash: vim: command not found
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# apt-get update
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# apt-get -y install vim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker commit -m=&#34;add cmd vim&#34; -a=&#34;jiayi&#34; e01aa0b39f6b myubuntu:1.1</span>
</span></span><span style=display:flex><span>sha256:b792ae050b8c53e1b02bf98fc547ddf3d4274788c1db15aa922fb872f358b387
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>myubuntu      1.1       b792ae050b8c   <span style=color:#ae81ff>6</span> seconds ago   182MB
</span></span><span style=display:flex><span>ubuntu        latest    ba6acccedd29   <span style=color:#ae81ff>17</span> months ago   72.8MB
</span></span><span style=display:flex><span>hello-world   latest    feb5d9fea6a5   <span style=color:#ae81ff>17</span> months ago   13.3kB
</span></span></code></pre></div><h4 id=推送本地镜像到阿里云>推送本地镜像到阿里云<a hidden class=anchor aria-hidden=true href=#推送本地镜像到阿里云>#</a></h4><p>打开阿里云</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314132105453.png alt=image-20230314132105453></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314131710745.png alt=image-20230314131710745></p><p>点击管理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#登录阿里云Docker Registry</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker login --username=238y0 registry.cn-hangzhou.aliyuncs.com</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#将镜像推送到Registry</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker tag b792ae050b8c registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker push registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314133317908.png alt=image-20230314133317908></p><h4 id=从阿里云拉取镜像到本地>从阿里云拉取镜像到本地<a hidden class=anchor aria-hidden=true href=#从阿里云拉取镜像到本地>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker pull registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span></code></pre></div><h3 id=本地镜像发布到私有仓库>本地镜像发布到私有仓库<a hidden class=anchor aria-hidden=true href=#本地镜像发布到私有仓库>#</a></h3><h4 id=harbor镜像仓库安装及使用>Harbor镜像仓库安装及使用<a hidden class=anchor aria-hidden=true href=#harbor镜像仓库安装及使用>#</a></h4><p><strong>Harbor简介</strong></p><p>Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：</p><ul><li><p>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</p></li><li><p>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</p></li><li><p>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</p></li><li><p>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</p></li></ul><p><strong>Harbor的安装</strong></p><p><strong>先安装docker-compose</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># curl -L &#34;https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)&#34; -o /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#给docker-compose添加执行权限</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># chmod +x /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose -v</span>
</span></span><span style=display:flex><span>Docker Compose version v2.16.0
</span></span></code></pre></div><p>下载Harbor的压缩包<a href=https://github.com/goharbor/harbor/releases>https://github.com/goharbor/harbor/releases</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#上传到linux服务器并解压</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># tar -zxf harbor-offline-installer-v1.10.17.tgz</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># mv harbor /opt/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#修改 harbor.yml，注释掉下面的四行</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># vi harbor.yml</span>
</span></span><span style=display:flex><span>hostname: 192.168.66.102
</span></span><span style=display:flex><span>port: <span style=color:#ae81ff>85</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#https:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  port: 443</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  certificate: /your/certificate/path</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  private_key: /your/private/key/path</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#安装harbor</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># ./prepare</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># ./install.sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#启动harbor</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose up -d</span>
</span></span></code></pre></div><p><strong>访问Harbor</strong></p><p>默认密码：Harbor12345</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314143949118.png alt=image-20230314143949118></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144147296.png alt=image-20230314144147296></p><p><strong>新建项目、创建用户</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144329226.png alt=image-20230314144329226></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144801725.png alt=image-20230314144801725></p><p><strong>给私有项目分配用户</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314145023809.png alt=image-20230314145023809></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314145204624.png alt=image-20230314145204624></p><ul><li>访客：对于指定项目拥有只读权限</li><li>开发人员：对于指定项目拥有读写权限</li><li>维护人员：对于指定项目拥有读写权限，创建 Webhooks</li><li>项目管理员：除了读写权限，同时拥有用户管理/镜像扫描等管理权限</li></ul><h4 id=把镜像上传到harbor>把镜像上传到Harbor<a hidden class=anchor aria-hidden=true href=#把镜像上传到harbor>#</a></h4><p><strong>把Harbor地址加入到Docker信任列表</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># vi /etc/docker/daemon.json</span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;registry-mirrors&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;https://5wr347bg.mirror.aliyuncs.com&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;insecure-registries&#34;</span>:<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;121.40.217.66:85&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># systemctl daemon-reload</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># systemctl restart docker</span>
</span></span></code></pre></div><p><strong>登录Harbor</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY       TAG        IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>myubuntu         1.1        a558d68de60a   <span style=color:#ae81ff>9</span> seconds ago   182MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker login -u 用户名 -p 密码 121.40.217.66:85
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#给镜像打标签</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker tag a558d68de60a 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#推送镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker push 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314154239997.png alt=image-20230314154239997></p><h4 id=从harbor上拉取镜像>从Harbor上拉取镜像<a hidden class=anchor aria-hidden=true href=#从harbor上拉取镜像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker pull 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span></code></pre></div><h3 id=docker容器数据卷>Docker容器数据卷<a hidden class=anchor aria-hidden=true href=#docker容器数据卷>#</a></h3><h4 id=数据卷是什么>数据卷是什么<a hidden class=anchor aria-hidden=true href=#数据卷是什么>#</a></h4><p>数据卷（Data Volumes）是宿主机中的一个目录或文件，数据卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><h4 id=为什么要用数据卷>为什么要用数据卷<a hidden class=anchor aria-hidden=true href=#为什么要用数据卷>#</a></h4><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。</p><p>数据卷的特点：</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><h4 id=数据卷的基本使用>数据卷的基本使用<a hidden class=anchor aria-hidden=true href=#数据卷的基本使用>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#创建数据卷</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume create mydata</span>
</span></span><span style=display:flex><span>mydata
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#列出所有数据卷</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume ls</span>
</span></span><span style=display:flex><span>DRIVER    VOLUME NAME
</span></span><span style=display:flex><span>local     mydata
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看数据卷信息</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume inspect mydata</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2023-03-14T16:36:47+08:00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/mydata/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;mydata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>容器和宿主机之间数据共享</strong></p><p>用 docker run 启动一个容器</p><p>-v &lt;宿主机目录或文件>:&lt;容器目录或文件>[:ro] #目录会自动创建</p><p>:ro 此项为只读，不写此项默认为可读可写</p><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it --name=u1 -v /tmp/hostdata:/tmp/dockerdata ubuntu</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps -n2</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS           PORTS     NAMES
</span></span><span style=display:flex><span>8b2cd2892e82   ubuntu    <span style=color:#e6db74>&#34;bash&#34;</span>    <span style=color:#ae81ff>35</span> minutes ago   Up <span style=color:#ae81ff>18</span> minutes              u1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看挂在目录</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker inspect 8b2cd2892e82</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Mounts&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Type&#34;</span>: <span style=color:#e6db74>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Source&#34;</span>: <span style=color:#e6db74>&#34;/tmp/hostdata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Destination&#34;</span>: <span style=color:#e6db74>&#34;/tmp/dockerdata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mode&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;RW&#34;</span>: true,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Propagation&#34;</span>: <span style=color:#e6db74>&#34;rprivate&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>,
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314172427107.png alt=image-20230314172427107></p><p>把容器停掉，在宿主机的/tmp/hostdata目录下新建a.txt文件，重新启动容器后在容器的/tmp/dockerdata目录下能看到a.txt</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314173553136.png alt=image-20230314173553136></p><p><strong>数据卷的继承</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it --name=u2 --volumes-from u1 ubuntu</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314180420410.png alt=image-20230314180420410></p><h3 id=docker安装部署中间件>Docker安装部署中间件<a hidden class=anchor aria-hidden=true href=#docker安装部署中间件>#</a></h3><h4 id=安装tomcat>安装tomcat<a hidden class=anchor aria-hidden=true href=#安装tomcat>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#拉取镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker pull tomcat</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#启动镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d --name=t1 -p 8888:8080 tomcat</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#tomcat8以上的版本需要把webapps.dist目录下的复制到webapps</span>
</span></span><span style=display:flex><span>root@0c4129d634bc:/usr/local/tomcat# rm -rf webapps
</span></span><span style=display:flex><span>root@0c4129d634bc:/usr/local/tomcat# mv webapps.dist webapps
</span></span></code></pre></div><p><strong>访问tomcat</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314193640896.png alt=image-20230314193640896></p><h4 id=安装mysql>安装MySQL<a hidden class=anchor aria-hidden=true href=#安装mysql>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 3306:3306 --name mysql \</span>
</span></span><span style=display:flex><span>&gt; -v /data/mysql/log:/var/log/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -v /data/mysql/data:/var/lib/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -v /data/mysql/conf:/etc/mysql/conf.d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> mysql:5.7
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#进入mysql容器登录mysql</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker exec -it mysql /bin/bash</span>
</span></span><span style=display:flex><span>root@a6bfec31c594:/# mysql -uroot -p
</span></span><span style=display:flex><span>Enter password: 
</span></span><span style=display:flex><span>mysql&gt; show databases;
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span>| Database           |
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span>| information_schema |
</span></span><span style=display:flex><span>| mysql              |
</span></span><span style=display:flex><span>| performance_schema |
</span></span><span style=display:flex><span>| sys                |
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> rows in set <span style=color:#f92672>(</span>0.00 sec<span style=color:#f92672>)</span>
</span></span></code></pre></div><h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3><h4 id=dockerfile的概述>Dockerfile的概述<a hidden class=anchor aria-hidden=true href=#dockerfile的概述>#</a></h4><p>Dockerfile 是一种被Docker程序解释的脚本，Dockerfile是由一条条的命令组成的，每条命令对应linux下面的一条命令，Docker程序将这些DockerFile指令再翻译成真正的linux命令，其有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docke镜像，避免了重复手动制作镜像的麻烦，类似与shell脚本一样，可以方便高效的制作镜像。</p><h4 id=dockerfile文件说明>Dockerfile文件说明<a hidden class=anchor aria-hidden=true href=#dockerfile文件说明>#</a></h4><ul><li>每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写</li><li>使用 # 开始作为注释</li><li>每一行只支持一条指令，每条指令可以携带多个参数</li><li>指令按文件的顺序从上至下执行</li><li>每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令</li></ul><h4 id=dockerfile指令介绍>Dockerfile指令介绍<a hidden class=anchor aria-hidden=true href=#dockerfile指令介绍>#</a></h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>LABEL</td><td>指定镜像元数据，如镜像作者</td></tr><tr><td>RUN</td><td>执行shell命令</td></tr><tr><td>COPY</td><td>拷贝文件和目录到镜像中</td></tr><tr><td>ADD</td><td>拷贝文件到镜像中，会自动处理URL和解压</td></tr><tr><td>ENV</td><td>设置环境变量</td></tr><tr><td>USER</td><td>指定镜像用什么用户去执行，不指定默认是root</td></tr><tr><td>WORKDIR</td><td>指定容器的工作目录</td></tr><tr><td>EXPOSE</td><td>暴露端口</td></tr><tr><td>VOLUME</td><td>数据卷，用作数据持久化</td></tr><tr><td>CMD</td><td>容器启动时执行的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被 docker run 之后的参数覆盖</td></tr><tr><td>ENTRYPOINT</td><td>容器启动时执行的命令。类似于CMD指令，不会被 docker run 之后的参数覆盖，而且这些命令行参数会被当作参数传给 ENTRYPOINT</td></tr></tbody></table><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20200223161407333-780x374.png alt=docker-dockerfile指令详细介绍插图></p><h4 id=自定义镜像>自定义镜像<a hidden class=anchor aria-hidden=true href=#自定义镜像>#</a></h4><p><strong>Dockerfile 制作基于基础镜像的Base镜像</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ubuntu<span style=color:#f92672>]</span><span style=color:#75715e># pwd</span>
</span></span><span style=display:flex><span>/data/dockerfile/os/ubuntu
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ubuntu<span style=color:#f92672>]</span><span style=color:#75715e># vim Dockerfile</span>
</span></span><span style=display:flex><span>FROM ubuntu:latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LABEL maintainer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;jiayi&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RUN apt-get update <span style=color:#f92672>&amp;&amp;</span> apt-get install -y vim net-tools make gcc libpcre3-dev zlib1g zlib1g-dev
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ubuntu<span style=color:#f92672>]</span><span style=color:#75715e># docker build -t ubuntu:v1.0 .</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ubuntu<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY        TAG        IMAGE ID       CREATED              SIZE
</span></span><span style=display:flex><span>ubuntu            v1.0       73e67d988202   <span style=color:#ae81ff>5</span> minutes ago        343MB
</span></span></code></pre></div><p><strong>Dockerfile 制作基于Base镜像的 nginx 镜像</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ nginx<span style=color:#f92672>]</span><span style=color:#75715e># pwd</span>
</span></span><span style=display:flex><span>/data/dockerfile/web/nginx
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ nginx<span style=color:#f92672>]</span><span style=color:#75715e># vim Dockerfile</span>
</span></span><span style=display:flex><span>FROM ubuntu:v1.0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LABEL maintainer<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;jiayi&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENV nginx_version nginx-1.23.3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>WORKDIR /usr/local/src/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ADD $nginx_version.tar.gz /usr/local/src
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>RUN cd /usr/local/src/$nginx_version <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> ./configure --prefix<span style=color:#f92672>=</span>/usr/local/nginx <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> make <span style=color:#f92672>&amp;&amp;</span> make install <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    <span style=color:#f92672>&amp;&amp;</span> useradd -s /sbin/nologin nginx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>COPY index.html /usr/local/nginx/html
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>VOLUME /usr/local/nginx/html
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENV PATH $PATH:/usr/local/nginx/sbin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>EXPOSE <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENTRYPOINT <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;nginx&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CMD <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;-g&#34;</span>,<span style=color:#e6db74>&#34;daemon off;&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ nginx<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY         TAG        IMAGE ID       CREATED             SIZE
</span></span><span style=display:flex><span>nginx-ubuntu       v1.23      a816e1d5d4c6   <span style=color:#ae81ff>3</span> minutes ago       373MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ nginx<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 80:80 nginx-ubuntu:v1.23 </span>
</span></span><span style=display:flex><span>46cebc2fe19f8658ec4e1038fa53a979fcfeb353769b787d177be3a5c931fe4a
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ nginx<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE                COMMAND                  CREATED         STATUS         PORTS                               NAMES
</span></span><span style=display:flex><span>46cebc2fe19f   nginx-ubuntu:v1.23   <span style=color:#e6db74>&#34;nginx -g &#39;daemon of…&#34;</span>   <span style=color:#ae81ff>3</span> seconds ago   Up <span style=color:#ae81ff>2</span> seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   tender_goldberg
</span></span></code></pre></div><p>访问nginx</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315143922329.png alt=image-20230315143922329></p><h3 id=docker网络>Docker网络<a hidden class=anchor aria-hidden=true href=#docker网络>#</a></h3><p>Docker启动后，会在每个宿主机会生成一个名称为docker0的网卡其IP地址是172.17.0.1/16</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># ifconfig |grep docker0 -A 8</span>
</span></span><span style=display:flex><span>docker0: flags<span style=color:#f92672>=</span>4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu <span style=color:#ae81ff>1500</span>
</span></span><span style=display:flex><span>        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
</span></span><span style=display:flex><span>        inet6 fe80::42:e7ff:fec0:1362  prefixlen <span style=color:#ae81ff>64</span>  scopeid 0x20&lt;link&gt;
</span></span><span style=display:flex><span>        ether 02:42:e7:c0:13:62  txqueuelen <span style=color:#ae81ff>0</span>  <span style=color:#f92672>(</span>Ethernet<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        RX packets <span style=color:#ae81ff>341435</span>  bytes <span style=color:#ae81ff>20873036</span> <span style=color:#f92672>(</span>19.9 MiB<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        RX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span>  overruns <span style=color:#ae81ff>0</span>  frame <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        TX packets <span style=color:#ae81ff>362121</span>  bytes <span style=color:#ae81ff>994179024</span> <span style=color:#f92672>(</span>948.1 MiB<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        TX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span> overruns <span style=color:#ae81ff>0</span>  carrier <span style=color:#ae81ff>0</span>  collisions <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p><strong>Docker的四种网络模式</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#列出docker网络</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker network ls</span>
</span></span><span style=display:flex><span>NETWORK ID     NAME            DRIVER    SCOPE
</span></span><span style=display:flex><span>fd6c253f44cc   bridge          bridge    local
</span></span><span style=display:flex><span>0a363a698c42   harbor_harbor   bridge    local
</span></span><span style=display:flex><span>3092b903331f   host            host      local
</span></span><span style=display:flex><span>fe599c88bd45   none            null      local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看docker网络</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker inspect host</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#创建docker网络</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker network create mynet</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#删除docker网络</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker network rm mynet</span>
</span></span></code></pre></div><p>bridge：Docker的默认网络模式，为容器分配IP，并将容器连接到docker0。</p><p>host：容器和宿主机共享 Network Namespace。</p><p>none：容器有独立的 Network Namespace，但并没有对他进行网络设置。</p><p>container：容器和另外一个容器共享 Network Namespace。</p><h3 id=docker-compose容器编排>Docker-compose容器编排<a hidden class=anchor aria-hidden=true href=#docker-compose容器编排>#</a></h3><h4 id=什么是docker-compose>什么是docker-compose<a hidden class=anchor aria-hidden=true href=#什么是docker-compose>#</a></h4><p>docker-compose 项目是Docker 官方的开源项目，负责实现对Docker 容器集群的快速编排，docker-compose 将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。</p><p>当在宿主机启动较多的容器时候，如果都是手动操作会觉得比较麻烦而且容易出错，docker-compose 是 docker 容器的一种编排服务，一个管理多个容器的工具。</p><p>可以解决容器之间的依赖关系，就像启动一个nginx 前端服务的时候会调用后端的tomcat，那就得先启动tomcat，但是启动tomcat 容器还需要依赖数据库，那就还得先启动数据库，docker-compose 可以用来解决这样的嵌套依赖关系，并且可以替代docker命令对容器进行创建、启动和停止等手工的操作。</p><p>如果说docker命令就像linux的命令，docker-compse就像shell脚本，可以自动的执行容器批量操作，从而实现自动化的容器管理，或者说docker命令相当于ansible命令，那么docker-compose文件，就相当于ansible-playbook的yaml文件。</p><h4 id=docker-compose的安装>docker-compose的安装<a hidden class=anchor aria-hidden=true href=#docker-compose的安装>#</a></h4><p>前面在讲本地镜像发布到Harbor的时候有安装过</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># curl -L &#34;https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)&#34; -o /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#给docker-compose添加执行权限</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># chmod +x /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose -v</span>
</span></span><span style=display:flex><span>Docker Compose version v2.16.0
</span></span></code></pre></div><h4 id=命令选项概述>命令选项概述<a hidden class=anchor aria-hidden=true href=#命令选项概述>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker-compose --help
</span></span><span style=display:flex><span>Define and run multi-container applications with Docker.
</span></span><span style=display:flex><span>Usage:
</span></span><span style=display:flex><span>  docker-compose <span style=color:#f92672>[</span>-f &lt;arg&gt;...<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>options<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>COMMAND<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>ARGS...<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  docker-compose -h|--help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#选项说明：</span>
</span></span><span style=display:flex><span>-f，–file FILE <span style=color:#75715e>#指定Compose 模板文件，默认为docker-compose.yml。</span>
</span></span><span style=display:flex><span>-p，–project-name NAME <span style=color:#75715e>#指定项目名称，默认将使用当前所在目录名称作为项目名。</span>
</span></span><span style=display:flex><span>--verbose   <span style=color:#75715e>#显示更多输出信息</span>
</span></span><span style=display:flex><span>--log-level LEVEL    <span style=color:#75715e>#定义日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL) </span>
</span></span><span style=display:flex><span>--no-ansi <span style=color:#75715e>#不显示ANSI 控制字符</span>
</span></span><span style=display:flex><span>-v, --version <span style=color:#75715e>#显示版本</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#以下为命令选项，需要在docker-compose.yml|yaml 文件所在在目录里执行 </span>
</span></span><span style=display:flex><span>build  <span style=color:#75715e>#构建镜像 </span>
</span></span><span style=display:flex><span>bundle <span style=color:#75715e>#从当前docker compose 文件生成一个以&lt;当前目录&gt;为名称的json格式的Docker Bundle 备份文件</span>
</span></span><span style=display:flex><span>config -q <span style=color:#75715e>#查看当前配置，没有错误不输出任何信息 </span>
</span></span><span style=display:flex><span>create <span style=color:#75715e>#创建服务</span>
</span></span><span style=display:flex><span>down <span style=color:#75715e>#停止和删除所有容器、网络、镜像和卷 </span>
</span></span><span style=display:flex><span><span style=color:#75715e>#events #从容器接收实时事件，可以指定json 日志格式，较少使用 </span>
</span></span><span style=display:flex><span>exec <span style=color:#75715e>#进入指定容器进行操作 </span>
</span></span><span style=display:flex><span>help <span style=color:#75715e>#显示帮助细信息 </span>
</span></span><span style=display:flex><span>images <span style=color:#75715e>#显示镜像信息</span>
</span></span><span style=display:flex><span>kill <span style=color:#75715e>#强制终止运行中的容器 </span>
</span></span><span style=display:flex><span>logs <span style=color:#75715e>#查看容器的日志 </span>
</span></span><span style=display:flex><span>pause <span style=color:#75715e>#暂停服务 </span>
</span></span><span style=display:flex><span>port <span style=color:#75715e>#查看端口 </span>
</span></span><span style=display:flex><span>ps <span style=color:#75715e>#列出容器</span>
</span></span><span style=display:flex><span>pull <span style=color:#75715e>#重新拉取镜像，镜像发生变化后，需要重新拉取镜像</span>
</span></span><span style=display:flex><span>push <span style=color:#75715e>#上传镜像 </span>
</span></span><span style=display:flex><span>restart <span style=color:#75715e>#重启服务 </span>
</span></span><span style=display:flex><span>rm <span style=color:#75715e>#删除已经停止的服务 </span>
</span></span><span style=display:flex><span>run <span style=color:#75715e>#一次性运行容器 </span>
</span></span><span style=display:flex><span>scale  <span style=color:#75715e>#设置指定服务运行的容器个数 </span>
</span></span><span style=display:flex><span>start <span style=color:#75715e>#启动服务</span>
</span></span><span style=display:flex><span>stop <span style=color:#75715e>#停止服务 </span>
</span></span><span style=display:flex><span>top <span style=color:#75715e>#显示容器运行状态 </span>
</span></span><span style=display:flex><span>unpause <span style=color:#75715e>#取消暂定 </span>
</span></span><span style=display:flex><span>up <span style=color:#75715e>#创建并启动容器</span>
</span></span></code></pre></div><p>docker-compose文件是一个yaml格式的文件，默认docker-compose命令会调用当前目录下的docker-compose.yml的文件，因此一般执行docker-compose命令前先进入docker-compose.yml文件所在目录。</p><h4 id=搭建wordpress>搭建wordpress<a hidden class=anchor aria-hidden=true href=#搭建wordpress>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ blog<span style=color:#f92672>]</span><span style=color:#75715e># vim compose.yml</span>
</span></span><span style=display:flex><span>services:
</span></span><span style=display:flex><span>  wordpress:
</span></span><span style=display:flex><span>    image: wordpress:latest
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;8000:80&#34;</span>
</span></span><span style=display:flex><span>    volumes:
</span></span><span style=display:flex><span>      - wordpress_data:/var/www/html
</span></span><span style=display:flex><span>    restart: always
</span></span><span style=display:flex><span>    depends_on:
</span></span><span style=display:flex><span>      - db
</span></span><span style=display:flex><span>    environment:
</span></span><span style=display:flex><span>      WORDPRESS_DB_HOST: db:3306
</span></span><span style=display:flex><span>      WORDPRESS_DB_USER: wordpress
</span></span><span style=display:flex><span>      WORDPRESS_DB_PASSWORD: wordpress
</span></span><span style=display:flex><span>      WORDPRESS_DB_NAME: wordpress
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  db:
</span></span><span style=display:flex><span>    image: mysql:5.7
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;3306:3306&#34;</span>
</span></span><span style=display:flex><span>    volumes:
</span></span><span style=display:flex><span>      - db_data:/var/lib/mysql
</span></span><span style=display:flex><span>    restart: always
</span></span><span style=display:flex><span>    environment:
</span></span><span style=display:flex><span>      MYSQL_ROOT_PASSWORD: <span style=color:#ae81ff>123456</span>
</span></span><span style=display:flex><span>      MYSQL_DATABASE: wordpress
</span></span><span style=display:flex><span>      MYSQL_USER: wordpress
</span></span><span style=display:flex><span>      MYSQL_PASSWORD: wordpress
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>volumes:
</span></span><span style=display:flex><span>  db_data:
</span></span><span style=display:flex><span>  wordpress_data:
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>#检查语法，加 -q 没有错误的话不会输出</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ blog<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose config</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#启动容器，可以看到启动过程，加 -d 后台运行</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ blog<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose up</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315200738586.png alt=image-20230315200738586></p><p>访问wordpress</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315201345452.png alt=image-20230315201345452></p><h3 id=可视化工具portainer>可视化工具Portainer<a hidden class=anchor aria-hidden=true href=#可视化工具portainer>#</a></h3><p>Portainer 是一个通用的容器管理平台，它提供了图形化界面，用于方便地管理Docker环境，包括单机环境和集群环境。</p><h4 id=安装portainer>安装Portainer<a hidden class=anchor aria-hidden=true href=#安装portainer>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 8100:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span>
</span></span></code></pre></div><p>访问Portainer ，创建用户</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315223716443.png alt=image-20230315223716443></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315224001583.png alt=image-20230315224001583></p><p>点击看板Dashboard，可以看到详细信息</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315224214952.png alt=image-20230315224214952></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230315224828580.png alt=image-20230315224828580></p><h3 id=docker-swarm>Docker Swarm<a hidden class=anchor aria-hidden=true href=#docker-swarm>#</a></h3><h4 id=什么是docker-swarm>什么是Docker Swarm<a hidden class=anchor aria-hidden=true href=#什么是docker-swarm>#</a></h4><p>Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在https://github.com/docker/swarm， 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的DockerClient(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p><p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p><p>Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p><h4 id=docker-swarm的架构>Docker Swarm的架构<a hidden class=anchor aria-hidden=true href=#docker-swarm的架构>#</a></h4><p>Swarm是典型的master-slave结构，通过发现服务来选举manager。Docker Client使用Swarm对 集群(Cluster)进行调度使用。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持。</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/20210420205540556.png alt=img></p><h4 id=swarm的几个关键概念>Swarm的几个关键概念<a hidden class=anchor aria-hidden=true href=#swarm的几个关键概念>#</a></h4><p><strong>Swarm</strong>：集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</p><p><strong>Node</strong>：分为管理 (manager) 节点和工作 (worker) 节点。</p><p><strong>manager节点</strong>用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。通常，第一个启用docker swarm的节点将成为leader，后来加入的都是follower。当前的leader如果挂掉，剩余的节点将重新选举出一个新的leader。每一个manager都有一个完整的当前集群状态的副本，可以保证manager的高可用。</p><p><strong>worker节点</strong>是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。worker节点之间，通过control plane进行通信，这种通信使用gossip协议，并且是异步的。</p><p><strong>Services</strong>：指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><p>replicated services：按照一定规则在各个工作节点上运行指定个数的任务。</p><p>global services：每个工作节点上运行一个任务</p><p><strong>Task</strong>：任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点。</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230316125306550.png alt=image-20230316125306550></p><h4 id=swarm的调度策略>Swarm的调度策略<a hidden class=anchor aria-hidden=true href=#swarm的调度策略>#</a></h4><p>Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：Spread，Binpack，Random。</p><p><strong>Spread</strong>：Spread策略会选择运行容器最少的那台节点来运行新的容器，使得容器会均衡的分布在集群中的各个节点上运行</p><p><strong>Binpack</strong>：Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在一个节点上面。</p><p><strong>Random</strong>：随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运行的容器的数量来计算应该运行容器的节点。</p><h4 id=swarm-cluster模式特性>Swarm Cluster模式特性<a hidden class=anchor aria-hidden=true href=#swarm-cluster模式特性>#</a></h4><p><strong>批量创建服务</strong>：建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</p><p><strong>强大的集群的容错性</strong>：当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值&ndash;replicas n，在集群中剩余的空闲节点上，重新拉起容器副本，整个副本迁移的过程无需人工干预。</p><p><strong>服务节点的可扩展性</strong>：Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale参数即可复制出新的副本出来。</p><p><strong>调度机制</strong>：所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</p><h4 id=dcoker-swarm-集群部署>Dcoker Swarm 集群部署<a hidden class=anchor aria-hidden=true href=#dcoker-swarm-集群部署>#</a></h4><p><strong>docker swarm 命令</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker swarm --help</span>
</span></span><span style=display:flex><span>Usage:  docker swarm COMMAND
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Manage Swarm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  ca          Display and rotate the root CA
</span></span><span style=display:flex><span>  init        Initialize a swarm
</span></span><span style=display:flex><span>  join        Join a swarm as a node and/or manager
</span></span><span style=display:flex><span>  join-token  Manage join tokens
</span></span><span style=display:flex><span>  leave       Leave the swarm
</span></span><span style=display:flex><span>  unlock      Unlock swarm
</span></span><span style=display:flex><span>  unlock-key  Manage the unlock key
</span></span><span style=display:flex><span>  update      Update the swarm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Run <span style=color:#e6db74>&#39;docker swarm COMMAND --help&#39;</span> <span style=color:#66d9ef>for</span> more information on a command.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node --help</span>
</span></span><span style=display:flex><span>Usage:  docker node COMMAND
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Manage Swarm nodes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  demote      Demote one or more nodes from manager in the swarm
</span></span><span style=display:flex><span>  inspect     Display detailed information on one or more nodes
</span></span><span style=display:flex><span>  ls          List nodes in the swarm
</span></span><span style=display:flex><span>  promote     Promote one or more nodes to manager in the swarm
</span></span><span style=display:flex><span>  ps          List tasks running on one or more nodes, defaults to current node
</span></span><span style=display:flex><span>  rm          Remove one or more nodes from the swarm
</span></span><span style=display:flex><span>  update      Update a node
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Run <span style=color:#e6db74>&#39;docker service COMMAND --help&#39;</span> <span style=color:#66d9ef>for</span> more information on a command.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service --help</span>
</span></span><span style=display:flex><span>Usage:  docker service COMMAND
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Manage services
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Commands:
</span></span><span style=display:flex><span>  create      Create a new service
</span></span><span style=display:flex><span>  inspect     Display detailed information on one or more services
</span></span><span style=display:flex><span>  logs        Fetch the logs of a service or task
</span></span><span style=display:flex><span>  ls          List services
</span></span><span style=display:flex><span>  ps          List the tasks of one or more services
</span></span><span style=display:flex><span>  rm          Remove one or more services
</span></span><span style=display:flex><span>  rollback    Revert changes to a service<span style=color:#e6db74>&#39;s configuration
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  scale       Scale one or multiple replicated services
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  update      Update a service
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Run &#39;</span>docker service COMMAND --help<span style=color:#960050;background-color:#1e0010>&#39;</span> <span style=color:#66d9ef>for</span> more information on a command.
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#创建Swarm集群</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker swarm init --advertise-addr 192.168.31.48</span>
</span></span><span style=display:flex><span>Swarm initialized: current node <span style=color:#f92672>(</span>lzhsbmrqtpg96gwlw193xes35<span style=color:#f92672>)</span> is now a manager.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To add a worker to this swarm, run the following command:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To add a manager to this swarm, run <span style=color:#e6db74>&#39;docker swarm join-token manager&#39;</span> and follow the instructions.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。其中，--advertise-addr参数表示其它swarm中的worker节点使用此ip地址与manager联系。命令的输出包含了其它节点如何加入集群的命令。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看Swarm状态</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker info |grep -i swarm</span>
</span></span><span style=display:flex><span> Swarm: active
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看Swarm节点信息</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node ls</span>
</span></span><span style=display:flex><span>ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
</span></span><span style=display:flex><span>lzhsbmrqtpg96gwlw193xes35 *   manager01   Ready     Active         Leader           20.10.16
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#添加节点主机到Swarm集群：分别在node01和node02上操作</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377</span>
</span></span><span style=display:flex><span>This node joined a swarm as a worker.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node02 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker swarm join --token SWMTKN-1-4bqtcm63yeg1ayb98p4xj5e5f2zmg1utx0gi4065zlzmm47m55-2znddl02ot5zyfnytalygcwno 192.168.31.48:2377</span>
</span></span><span style=display:flex><span>This node joined a swarm as a worker.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#再次查看Swarm节点信息</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node ls</span>
</span></span><span style=display:flex><span>ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
</span></span><span style=display:flex><span>lzhsbmrqtpg96gwlw193xes35 *   manager01   Ready     Active         Leader           20.10.16
</span></span><span style=display:flex><span>jjl18ughg79ht0jbf7xiuzfdq     node01      Ready     Active                          23.0.1
</span></span><span style=display:flex><span>16ypcv81ozwxiruechzrvjye5     node02      Ready     Active                          23.0.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#把node02节点的AVAILABILITY设置为Drain</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node update --availability drain node02</span>
</span></span><span style=display:flex><span>node02
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node ls</span>
</span></span><span style=display:flex><span>ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
</span></span><span style=display:flex><span>lzhsbmrqtpg96gwlw193xes35 *   manager01   Ready     Active         Leader           20.10.16
</span></span><span style=display:flex><span>jjl18ughg79ht0jbf7xiuzfdq     node01      Ready     Active                          23.0.1
</span></span><span style=display:flex><span>16ypcv81ozwxiruechzrvjye5     node02      Ready     Drain                           23.0.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#把node02节点的AVAILABILITY设置为Active</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node update --availability active node02</span>
</span></span><span style=display:flex><span>node02
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node ls</span>
</span></span><span style=display:flex><span>ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
</span></span><span style=display:flex><span>lzhsbmrqtpg96gwlw193xes35 *   manager01   Ready     Active         Leader           20.10.16
</span></span><span style=display:flex><span>jjl18ughg79ht0jbf7xiuzfdq     node01      Ready     Active                          23.0.1
</span></span><span style=display:flex><span>16ypcv81ozwxiruechzrvjye5     node02      Ready     Active                          23.0.1
</span></span></code></pre></div><blockquote><p>swarm集群中node的 AVAILABILITY 状态可以为 Active，Drain，Pause。</p><p>Active：node可以接受来自manager节点的任务分派</p><p>Drain：node节点会结束现有task并将其调度到其他节点，且不再接受来自manager节点的任务分派</p><p>Pause：manager节点不会把任务分派给node节点，但现有task会继续运行</p></blockquote><h4 id=在swarm中部署nginx>在Swarm中部署nginx<a hidden class=anchor aria-hidden=true href=#在swarm中部署nginx>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#创建网络</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker network create -d overlay nginx</span>
</span></span><span style=display:flex><span>1s1t6r59c0pplpd32kkznthb0
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker network ls |grep nginx</span>
</span></span><span style=display:flex><span>1s1t6r59c0pp   nginx             overlay   swarm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#创建一个具有一个副本（--replicas=1）的nginx服务</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service create --name=mynginx --replicas=1 --network=nginx -p 80:80 nginx </span>
</span></span><span style=display:flex><span>yuoo1c8gm631xxx6ve3zyld6n
</span></span><span style=display:flex><span>overall progress: <span style=color:#ae81ff>1</span> out of <span style=color:#ae81ff>1</span> tasks 
</span></span><span style=display:flex><span>1/1: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>verify: Service converged 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看服务列表</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>yuoo1c8gm631   mynginx   replicated   1/1        nginx:latest   *:80-&gt;80/tcp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查询swarm中服务的信息</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service inspect --pretty mynginx</span>
</span></span><span style=display:flex><span>ID:		yuoo1c8gm631xxx6ve3zyld6n
</span></span><span style=display:flex><span>Name:		mynginx
</span></span><span style=display:flex><span>Service Mode:	Replicated
</span></span><span style=display:flex><span> Replicas:	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Placement:
</span></span><span style=display:flex><span>UpdateConfig:
</span></span><span style=display:flex><span> Parallelism:	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> On failure:	pause
</span></span><span style=display:flex><span> Monitoring Period: 5s
</span></span><span style=display:flex><span> Max failure ratio: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> Update order:      stop-first
</span></span><span style=display:flex><span>RollbackConfig:
</span></span><span style=display:flex><span> Parallelism:	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> On failure:	pause
</span></span><span style=display:flex><span> Monitoring Period: 5s
</span></span><span style=display:flex><span> Max failure ratio: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> Rollback order:    stop-first
</span></span><span style=display:flex><span>ContainerSpec:
</span></span><span style=display:flex><span> Image:		nginx:latest@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31
</span></span><span style=display:flex><span> Init:		false
</span></span><span style=display:flex><span>Resources:
</span></span><span style=display:flex><span>Networks: nginx 
</span></span><span style=display:flex><span>Endpoint Mode:	vip
</span></span><span style=display:flex><span>Ports:
</span></span><span style=display:flex><span> PublishedPort <span style=color:#f92672>=</span> <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>  Protocol <span style=color:#f92672>=</span> tcp
</span></span><span style=display:flex><span>  TargetPort <span style=color:#f92672>=</span> <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>  PublishMode <span style=color:#f92672>=</span> ingress 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>#查询mynginx服务在哪个节点运行</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME        IMAGE          NODE        DESIRED STATE   CURRENT STATE           ERROR     PORTS
</span></span><span style=display:flex><span>jcp8a0kg2m4p   mynginx.1   nginx:latest   manager01   Running         Running <span style=color:#ae81ff>6</span> minutes ago
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#在manager01的节点可以看到nginx容器正在运行</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS     NAMES
</span></span><span style=display:flex><span>afafbe099b69   nginx:latest   <span style=color:#e6db74>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#ae81ff>7</span> minutes ago   Up <span style=color:#ae81ff>7</span> minutes   80/tcp    mynginx.1.jcp8a0kg2m4p7ejy3v9p55zlp
</span></span></code></pre></div><p><strong>在Swarm的动态扩容(scale)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#将mynginx服务动态扩展到4个</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service scale mynginx=4</span>
</span></span><span style=display:flex><span>mynginx scaled to <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>overall progress: <span style=color:#ae81ff>4</span> out of <span style=color:#ae81ff>4</span> tasks 
</span></span><span style=display:flex><span>1/4: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>2/4: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>3/4: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>4/4: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>verify: Service converged
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看服务列表和运行节点</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>yuoo1c8gm631   mynginx   replicated   4/4        nginx:latest   *:80-&gt;80/tcp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME        IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
</span></span><span style=display:flex><span>jcp8a0kg2m4p   mynginx.1   nginx:latest   manager01   Running         Running <span style=color:#ae81ff>12</span> minutes ago             
</span></span><span style=display:flex><span>opvyk40r2v7t   mynginx.2   nginx:latest   node02      Running         Running <span style=color:#ae81ff>44</span> seconds ago             
</span></span><span style=display:flex><span>mwonwvdb3hq6   mynginx.3   nginx:latest   node02      Running         Running <span style=color:#ae81ff>44</span> seconds ago             
</span></span><span style=display:flex><span>i4l00g7nhsl7   mynginx.4   nginx:latest   node01      Running         Running <span style=color:#ae81ff>45</span> seconds ago
</span></span></code></pre></div><p><strong>模拟node02节点宕机</strong></p><p>如果一个节点宕机了（即该节点就会从swarm集群中被踢出），Docker会将在该节点运行的容器，调度到其他节点，以满足指定数量的副本（replicas）保持运行状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#停掉node02的docker服务</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node02 ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl stop docker</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker node ls</span>
</span></span><span style=display:flex><span>ID                            HOSTNAME    STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
</span></span><span style=display:flex><span>lzhsbmrqtpg96gwlw193xes35 *   manager01   Ready     Active         Leader           20.10.16
</span></span><span style=display:flex><span>jjl18ughg79ht0jbf7xiuzfdq     node01      Ready     Active                          23.0.1
</span></span><span style=display:flex><span>16ypcv81ozwxiruechzrvjye5     node02      Down      Active                          23.0.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#可以看到node02上的task实例已经转移到别的节点上了</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>yuoo1c8gm631   mynginx   replicated   6/4        nginx:latest   *:80-&gt;80/tcp
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME            IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
</span></span><span style=display:flex><span>jcp8a0kg2m4p   mynginx.1       nginx:latest   manager01   Running         Running <span style=color:#ae81ff>20</span> minutes ago             
</span></span><span style=display:flex><span>93di7mqaug77   mynginx.2       nginx:latest   node01      Running         Running <span style=color:#ae81ff>14</span> seconds ago             
</span></span><span style=display:flex><span>opvyk40r2v7t    <span style=color:#ae81ff>\_</span> mynginx.2   nginx:latest   node02      Shutdown        Running <span style=color:#ae81ff>8</span> minutes ago              
</span></span><span style=display:flex><span>iszkb164456y   mynginx.3       nginx:latest   manager01   Running         Running <span style=color:#ae81ff>14</span> seconds ago             
</span></span><span style=display:flex><span>mwonwvdb3hq6    <span style=color:#ae81ff>\_</span> mynginx.3   nginx:latest   node02      Shutdown        Running <span style=color:#ae81ff>8</span> minutes ago              
</span></span><span style=display:flex><span>i4l00g7nhsl7   mynginx.4       nginx:latest   node01      Running         Running <span style=color:#ae81ff>8</span> minutes ago
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS     NAMES
</span></span><span style=display:flex><span>f03222f6428b   nginx:latest   <span style=color:#e6db74>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#ae81ff>3</span> minutes ago    Up <span style=color:#ae81ff>3</span> minutes    80/tcp    mynginx.3.iszkb164456y0exea29uiqxwx
</span></span><span style=display:flex><span>afafbe099b69   nginx:latest   <span style=color:#e6db74>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#ae81ff>23</span> minutes ago   Up <span style=color:#ae81ff>23</span> minutes   80/tcp    mynginx.1.jcp8a0kg2m4p7ejy3v9p55zlp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE          COMMAND                   CREATED          STATUS          PORTS     NAMES
</span></span><span style=display:flex><span>1ed4ee89030b   nginx:latest   <span style=color:#e6db74>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#ae81ff>3</span> minutes ago    Up <span style=color:#ae81ff>3</span> minutes    80/tcp    mynginx.2.93di7mqaug7798528qz1nlixl
</span></span><span style=display:flex><span>71b69284f5ef   nginx:latest   <span style=color:#e6db74>&#34;/docker-entrypoint.…&#34;</span>   <span style=color:#ae81ff>11</span> minutes ago   Up <span style=color:#ae81ff>11</span> minutes   80/tcp    mynginx.4.i4l00g7nhsl7ka1w3l6be8zgy
</span></span></code></pre></div><p><strong>在Swarm的动态缩容(scale)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#将mynginx服务动态缩容到4个</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service scale mynginx=1</span>
</span></span><span style=display:flex><span>mynginx scaled to <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>overall progress: <span style=color:#ae81ff>1</span> out of <span style=color:#ae81ff>1</span> tasks 
</span></span><span style=display:flex><span>1/1: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>verify: Service converged 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看服务列表和运行节点</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>yuoo1c8gm631   mynginx   replicated   1/1        nginx:latest   *:80-&gt;80/tcp
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME        IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
</span></span><span style=display:flex><span>jcp8a0kg2m4p   mynginx.1   nginx:latest   manager01   Running         Running <span style=color:#ae81ff>30</span> minutes ago             
</span></span><span style=display:flex><span>opvyk40r2v7t   mynginx.2   nginx:latest   node02      Shutdown        Shutdown <span style=color:#ae81ff>2</span> minutes ago             
</span></span><span style=display:flex><span>mwonwvdb3hq6   mynginx.3   nginx:latest   node02      Shutdown        Shutdown <span style=color:#ae81ff>2</span> minutes ago
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#登录node节点查看已经没有nginx在运行了</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@node02 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></span></code></pre></div><p>除了上面使用scale进行容器的扩容或缩容之外，还可以使用docker service update 命令。 可对服务的启动参数 进行更新/修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service update --replicas=3 mynginx</span>
</span></span><span style=display:flex><span>mynginx
</span></span><span style=display:flex><span>overall progress: <span style=color:#ae81ff>3</span> out of <span style=color:#ae81ff>3</span> tasks 
</span></span><span style=display:flex><span>1/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>2/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>3/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>verify: Service converged 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>yuoo1c8gm631   mynginx   replicated   3/3        nginx:latest   *:80-&gt;80/tcp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME            IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
</span></span><span style=display:flex><span>jcp8a0kg2m4p   mynginx.1       nginx:latest   manager01   Running         Running <span style=color:#ae81ff>38</span> minutes ago             
</span></span><span style=display:flex><span>h9kouj0noeed   mynginx.2       nginx:latest   node01      Running         Running <span style=color:#ae81ff>15</span> seconds ago             
</span></span><span style=display:flex><span>opvyk40r2v7t    <span style=color:#ae81ff>\_</span> mynginx.2   nginx:latest   node02      Shutdown        Shutdown <span style=color:#ae81ff>9</span> minutes ago             
</span></span><span style=display:flex><span>mxbe15gl0000   mynginx.3       nginx:latest   node02      Running         Running <span style=color:#ae81ff>14</span> seconds ago             
</span></span><span style=display:flex><span>mwonwvdb3hq6    <span style=color:#ae81ff>\_</span> mynginx.3   nginx:latest   node02      Shutdown        Shutdown <span style=color:#ae81ff>9</span> minutes ago
</span></span></code></pre></div><h4 id=在swarm中使用volume>在Swarm中使用volume<a hidden class=anchor aria-hidden=true href=#在swarm中使用volume>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#为了方便把前面的mynginx服务删掉</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service rm mynginx</span>
</span></span><span style=display:flex><span>mynginx
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID        NAME      MODE      REPLICAS   IMAGE     PORTS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#创建volume</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker volume create nginx_data</span>
</span></span><span style=display:flex><span>nginx_data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看volume详情</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker volume inspect nginx_data</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2023-03-16T16:08:21+08:00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: <span style=color:#f92672>{}</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/nginx_data/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;nginx_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: <span style=color:#f92672>{}</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>部署nginx服务并挂载nginx_data</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service create --name=mynginx --replicas=3 --mount type=volume,src=nginx_data,dst=/data nginx</span>
</span></span><span style=display:flex><span>jxft6qg4w09znm7yyl7z98tgv
</span></span><span style=display:flex><span>overall progress: <span style=color:#ae81ff>3</span> out of <span style=color:#ae81ff>3</span> tasks 
</span></span><span style=display:flex><span>1/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>2/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>3/3: running   <span style=color:#f92672>[==================================================</span>&gt;<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>verify: Service converged 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看服务列表和运行节点</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME      MODE         REPLICAS   IMAGE          PORTS
</span></span><span style=display:flex><span>jxft6qg4w09z   mynginx   replicated   3/3        nginx:latest   
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 ~<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps mynginx</span>
</span></span><span style=display:flex><span>ID             NAME        IMAGE          NODE        DESIRED STATE   CURRENT STATE            ERROR     PORTS
</span></span><span style=display:flex><span>iqgz3ddomq4c   mynginx.1   nginx:latest   node01      Running         Running <span style=color:#ae81ff>21</span> seconds ago             
</span></span><span style=display:flex><span>eo54f0022ghj   mynginx.2   nginx:latest   node02      Running         Running <span style=color:#ae81ff>21</span> seconds ago             
</span></span><span style=display:flex><span>pde6k6qzik5g   mynginx.3   nginx:latest   manager01   Running         Running <span style=color:#ae81ff>21</span> seconds ago
</span></span></code></pre></div><h4 id=多服务swarm集群部署>多服务Swarm集群部署<a hidden class=anchor aria-hidden=true href=#多服务swarm集群部署>#</a></h4><p>docker service部署的是单个服务，可以使用docker stack进行多服务编排部署</p><p>我们这里部署三个服务（Nginx，Visualizer，Portainer）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#编写docker-compose.yml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 swarm<span style=color:#f92672>]</span><span style=color:#75715e># vim docker-compose.yml</span>
</span></span><span style=display:flex><span>version: <span style=color:#e6db74>&#34;3&#34;</span>
</span></span><span style=display:flex><span>services:
</span></span><span style=display:flex><span>  web:
</span></span><span style=display:flex><span>    image: nginx
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;8088:80&#34;</span>
</span></span><span style=display:flex><span>    deploy:
</span></span><span style=display:flex><span>      mode: replicated
</span></span><span style=display:flex><span>      replicas: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  visualize:
</span></span><span style=display:flex><span>    image: dockersamples/visualizer
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;8080:8080&#34;</span>
</span></span><span style=display:flex><span>    volumes:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;/var/run/docker.sock:/var/run/docker.sock&#34;</span>
</span></span><span style=display:flex><span>    deploy:
</span></span><span style=display:flex><span>      replicas: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      placement:
</span></span><span style=display:flex><span>        constraints: <span style=color:#f92672>[</span>node.role <span style=color:#f92672>==</span> manager<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  portainer:
</span></span><span style=display:flex><span>    image: portainer/portainer
</span></span><span style=display:flex><span>    ports:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;9000:9000&#34;</span>
</span></span><span style=display:flex><span>    volumes:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;/var/run/docker.sock:/var/run/docker.sock&#34;</span>
</span></span><span style=display:flex><span>    environment:
</span></span><span style=display:flex><span>      - TZ<span style=color:#f92672>=</span>Asia/Shanghai
</span></span><span style=display:flex><span>    deploy:
</span></span><span style=display:flex><span>      replicas: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>      placement:
</span></span><span style=display:flex><span>        constraints: <span style=color:#f92672>[</span>node.role <span style=color:#f92672>==</span> manager<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#75715e>#查看服务列表和运行节点</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 swarm<span style=color:#f92672>]</span><span style=color:#75715e># docker service ls</span>
</span></span><span style=display:flex><span>ID             NAME            MODE         REPLICAS   IMAGE                             PORTS
</span></span><span style=display:flex><span>ypgunrzwoh7o   nvp_portainer   replicated   1/1        portainer/portainer:latest        *:9000-&gt;9000/tcp
</span></span><span style=display:flex><span>ksyai2lpcq8s   nvp_visualize   replicated   1/1        dockersamples/visualizer:latest   *:8080-&gt;8080/tcp
</span></span><span style=display:flex><span>k6h4attw960j   nvp_web         replicated   3/3        nginx:latest                      *:8088-&gt;80/tcp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 swarm<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps nvp_portainer</span>
</span></span><span style=display:flex><span>ID             NAME              IMAGE                        NODE        DESIRED STATE   CURRENT STATE                ERROR     PORTS
</span></span><span style=display:flex><span>bvvxgdz08364   nvp_portainer.1   portainer/portainer:latest   manager01   Running         Running about a minute ago
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 swarm<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps nvp_visualize</span>
</span></span><span style=display:flex><span>ID             NAME              IMAGE                             NODE        DESIRED STATE   CURRENT STATE                ERROR     PORTS
</span></span><span style=display:flex><span>0b40xkse08na   nvp_visualize.1   dockersamples/visualizer:latest   manager01   Running         Running about a minute ago
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@manager01 swarm<span style=color:#f92672>]</span><span style=color:#75715e># docker service ps nvp_web</span>
</span></span><span style=display:flex><span>ID             NAME        IMAGE          NODE        DESIRED STATE   CURRENT STATE           ERROR     PORTS
</span></span><span style=display:flex><span>c2jbbwjc2tui   nvp_web.1   nginx:latest   manager01   Running         Running <span style=color:#ae81ff>2</span> minutes ago             
</span></span><span style=display:flex><span>ue1wjtxcc8y7   nvp_web.2   nginx:latest   node01      Running         Running <span style=color:#ae81ff>2</span> minutes ago             
</span></span><span style=display:flex><span>x674wr3gmk5b   nvp_web.3   nginx:latest   node02      Running         Running <span style=color:#ae81ff>2</span> minutes ago
</span></span></code></pre></div><p><strong>验证</strong></p><p>访问http://192.168.31.48:8080/</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230316175535987.png alt=image-20230316175535987></p><p>访问http://192.168.31.48:9000/</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230316175627276.png alt=image-20230316175627276></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiayi26.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://jiayi26.github.io/posts/ansible/><span class=title>« Prev Page</span><br><span></span></a>
<a class=next href=https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/><span class=title>Next Page »</span><br><span>InnoDB数据存储结构</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker on twitter" href="https://twitter.com/intent/tweet/?text=Docker&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&hashtags=Docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&title=Docker&summary=Docker&source=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&title=Docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20-%20https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on telegram" href="https://telegram.me/share/url?text=Docker&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>