<!doctype html><html lang=en dir=auto><head><meta name="referrer" content="no-referrer"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker | JIAYI's Blog</title><meta name=keywords content="Docker"><meta name=description content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/posts/docker/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker"><meta property="og:description" content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><meta property="og:type" content="article"><meta property="og:url" content="https://jiayi26.github.io/posts/docker/"><meta property="article:section" content="posts"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 &ldquo;Build，Ship and Run Any App,Anywhere&rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiayi26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker","item":"https://jiayi26.github.io/posts/docker/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker","name":"Docker","description":"Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 \u0026ldquo;Build，Ship and Run Any App,Anywhere\u0026rdquo;，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。\nDocker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。\n容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。\n虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。\n 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例\n卸载旧版本 [root@test_server ~]# yum remove docker \\ \u0026gt; docker-client \\ \u0026gt; docker-client-latest \\ \u0026gt; docker-common \\ \u0026gt; docker-latest \\ \u0026gt; docker-latest-logrotate \\ \u0026gt; docker-logrotate \\ \u0026gt; docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的","keywords":["Docker"],"articleBody":"Docker的概述 什么是Docker  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。  Docker的主要目标 “Build，Ship and Run Any App,Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。\nDocker的组成  镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/   容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。\n容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。\n虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。\n 资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理   Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例\n卸载旧版本 [root@test_server ~]# yum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的\n#安装必要的一些系统工具 [root@test_server ~]# yum install -y yum-utils  #添加阿里云镜像仓库 [root@test_server ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  #更新yum软件包索引 [root@test_server ~]# yum makecache 安装启动Docker [root@test_server ~]# yum install -y docker-ce docker-ce-cli containerd.io [root@test_server ~]# systemctl start docker [root@test_server ~]# systemctl enable docker 验证 #查看版本 [root@test_server ~]# docker version  #hello-world [root@test_server ~]# docker run hello-world 卸载\n[root@test_server ~]# yum remove docker-ce docker-ce-cli containerd.io [root@test_server ~]# rm -rf /var/lib/docker [root@test_server ~]# rm -rf /var/lib/containerd 配置阿里云镜像加速 https://cr.console.aliyun.com/\n[root@test_server ~]# mkdir -p /etc/docker [root@test_server ~]# tee /etc/docker/daemon.json   {  \"registry-mirrors\": [\"你的加速器地址\"]  }  EOF  [root@test_server ~]# systemctl daemon-reload [root@test_server ~]# systemctl restart docker Docker常用命令 帮助类命令    命令 解释     docker –help 查看docker帮助文档   docker 具体命令 –help 查看docker具体命令帮助文档    镜像命令    命令 解释     docker images 查看本地的镜像   docker search 镜像名字 搜索镜像   docker pull 镜像名字 拉取镜像   docker rmi 镜像ID或名字 删除镜像   docker system df 查看镜像、容器、数据卷所占空间    容器命令    命令 解释     docker run 启动容器   docker ps 当前正在运行的容器   docker start 容器ID或容器名 启动已停止运行的容器   docker restart 容器ID或容器名 重启容器   docker stop 容器ID或容器名 停止容器   docker kill 容器ID或容器名 强制停止容器   docker rm 容器ID或容器名 删除已停止的容器   docker logs 容器ID 查看容器日志   docker top 容器ID 查看容器内进程   docker inspect 容器ID 查看容器内部细节   docker cp 容器ID:容器文件路径 目的主机路径 从容器内拷贝文件到目的主机   docker export 容器ID  文件名.tar 导出容器内容作为一个tar归档文件   cat 文件名.tar | docker import - 镜像名 导入镜像   docker exec -it 容器ID 进入容器（exit退出，容器不停止）   docker attach 容器ID 进入容器（exit退出，容器停止）    #docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] [root@test_server ~]# docker run -d -p 80:80 --name=mynginx nginx -i：交互式 -t：终端 -d：以后台的方式运行容器 -P：随机映射端口 -p：指定映射端口 --name=镜像名字：为容器指定一个名字 exit：退出容器，容器停止 ctrl+p+q：退出容器，容器不停止    命令 描述 解释     attach Attach to a running container 当前 shell 下 attach 连接指定运行镜像   build Build an image from a Dockerfile 通过 Dockerfile 定制镜像   commit Create a new image from a container changes 提交当前容器为新的镜像   cp Copy files/folders from the containers filesystem to the host path 从容器中拷贝指定文件或者目录到宿主机中   create Create a new container 创建一个新的容器，同 run，但不启动容器   diff Inspect changes on a container’s filesystem 查看 docker 容器变化   events Get real time events from the server 从 docker 服务获取容器实时事件   exec Run a command in an existing container 在已存在的容器上运行命令   export Stream the contents of a container as a tar archive 导出容器的内容流作为一个 tar 归档文件[对应 import ]   history Show the history of an image 展示一个镜像形成历史   images List images 列出系统当前镜像   import Create a new filesystem image from the contents of a tarball 从tar包中的内容创建一个新的文件系统映像[对应export]   info Display system-wide information 显示系统相关信息   inspect Return low-level information on a container 查看容器详细信息   kill Kill a running container kill 指定 docker 容器   load Load an image from a tar archive 从一个 tar 包中加载一个镜像[对应 save]   login Register or Login to the docker registry server 注册或者登陆一个 docker 源服务器   logout Log out from a Docker registry server 从当前 Docker registry 退出   logs Fetch the logs of a container 输出当前容器日志信息   port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT 查看映射端口对应的容器内部源端口   pause Pause all processes within a container 暂停容器   ps List containers 列出容器列表   pull Pull an image or a repository from the docker registry server 从docker镜像源服务器拉取指定镜像或者库镜像   push Push an image or a repository to the docker registry server 推送指定镜像或者库镜像至docker源服务器   restart Restart a running container 重启运行的容器   rm Remove one or more containers 移除一个或者多个容器   rmi Remove one or more images 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]   run Run a command in a new container 创建一个新的容器并运行一个命令   save Save an image to a tar archive 保存一个镜像为一个 tar 包[对应 load]   search Search for an image on the Docker Hub 在 docker hub 中搜索镜像   start Start a stopped containers 启动容器   stop Stop a running containers 停止容器   tag Tag an image into a repository 给源中镜像打标签   top Lookup the running processes of a container 查看容器中运行的进程信息   unpause Unpause a paused container 取消暂停容器   version Show the docker version information 查看 docker 版本号   wait Block until a container stops, then print its exit code 截取容器停止时的退出状态值    Docker镜像 什么是镜像 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。\nUnionFS（联合文件系统） Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\nDocker镜像加载原理 Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n本地镜像发布到阿里云 本地先生成一个镜像 #原始的ubuntu镜像是不带vim命令的，我们安装vim命令并commit新镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it ubuntu root@e01aa0b39f6b:/# vim a.txt bash: vim: command not found  root@e01aa0b39f6b:/# apt-get update root@e01aa0b39f6b:/# apt-get -y install vim  [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker commit -m=\"add cmd vim\" -a=\"jiayi\" e01aa0b39f6b myubuntu:1.1 sha256:b792ae050b8c53e1b02bf98fc547ddf3d4274788c1db15aa922fb872f358b387 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE myubuntu 1.1 b792ae050b8c 6 seconds ago 182MB ubuntu latest ba6acccedd29 17 months ago 72.8MB hello-world latest feb5d9fea6a5 17 months ago 13.3kB 推送本地镜像到阿里云 打开阿里云\n点击管理\n#登录阿里云Docker Registry [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker login --username=238y0 registry.cn-hangzhou.aliyuncs.com  #将镜像推送到Registry [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker tag b792ae050b8c registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker push registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 从阿里云拉取镜像到本地 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker pull registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1 本地镜像发布到私有仓库 Harbor镜像仓库安装及使用 Harbor简介\nHarbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：\n  提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。\n  提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。\n  支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。\n  良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。\n  Harbor的安装\n先安装docker-compose\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# curl -L \"https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose  #给docker-compose添加执行权限 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# chmod +x /usr/local/bin/docker-compose [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker-compose -v Docker Compose version v2.16.0 下载Harbor的压缩包https://github.com/goharbor/harbor/releases\n#上传到linux服务器并解压 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# tar -zxf harbor-offline-installer-v1.10.17.tgz [root@iZbp162vx7bwpqiv8pmpdvZ ~]# mv harbor /opt/  #修改 harbor.yml，注释掉下面的四行 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# vi harbor.yml hostname: 192.168.66.102 port: 85 #https: # port: 443 # certificate: /your/certificate/path # private_key: /your/private/key/path  #安装harbor [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# ./prepare [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# ./install.sh  #启动harbor [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker-compose up -d 访问Harbor\n默认密码：Harbor12345\n新建项目、创建用户\n给私有项目分配用户\n 访客：对于指定项目拥有只读权限 开发人员：对于指定项目拥有读写权限 维护人员：对于指定项目拥有读写权限，创建 Webhooks 项目管理员：除了读写权限，同时拥有用户管理/镜像扫描等管理权限  把镜像上传到Harbor 把Harbor地址加入到Docker信任列表\n[root@iZbp162vx7bwpqiv8pmpdvZ harbor]# vi /etc/docker/daemon.json {  \"registry-mirrors\": [\"https://5wr347bg.mirror.aliyuncs.com\"]  \"insecure-registries\":[\"121.40.217.66:85\"] } [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# systemctl daemon-reload [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# systemctl restart docker 登录Harbor\n[root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE myubuntu 1.1 a558d68de60a 9 seconds ago 182MB  docker login -u 用户名 -p 密码 121.40.217.66:85  #给镜像打标签 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker tag a558d68de60a 121.40.217.66:85/ops/myubuntu:1.1  #推送镜像 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker push 121.40.217.66:85/ops/myubuntu:1.1 从Harbor上拉取镜像 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker pull 121.40.217.66:85/ops/myubuntu:1.1 Docker容器数据卷 数据卷是什么 数据卷（Data Volumes）是宿主机中的一个目录或文件，数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n为什么要用数据卷 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。\n数据卷的特点：\n 数据卷可在容器之间共享或重用数据 卷中的更改可以直接实时生效 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止  数据卷的基本使用 #创建数据卷 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume create mydata mydata  #列出所有数据卷 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume ls DRIVER VOLUME NAME local mydata  #查看数据卷信息 [root@iZbp162vx7bwpqiv8pmpdvZ harbor]# docker volume inspect mydata [  {  \"CreatedAt\": \"2023-03-14T16:36:47+08:00\",  \"Driver\": \"local\",  \"Labels\": null,  \"Mountpoint\": \"/var/lib/docker/volumes/mydata/_data\",  \"Name\": \"mydata\",  \"Options\": null,  \"Scope\": \"local\"  } ] 容器和宿主机之间数据共享\n用 docker run 启动一个容器\n-v :[:ro]\t#目录会自动创建\n:ro 此项为只读，不写此项默认为可读可写\n举例：\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it --name=u1 -v /tmp/hostdata:/tmp/dockerdata ubuntu  [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker ps -n2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8b2cd2892e82 ubuntu \"bash\" 35 minutes ago Up 18 minutes u1  #查看挂在目录 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker inspect 8b2cd2892e82 \"Mounts\": [  {  \"Type\": \"bind\",  \"Source\": \"/tmp/hostdata\",  \"Destination\": \"/tmp/dockerdata\",  \"Mode\": \"\",  \"RW\": true,  \"Propagation\": \"rprivate\"  } ], 把容器停掉，在宿主机的/tmp/hostdata目录下新建a.txt文件，重新启动容器后在容器的/tmp/dockerdata目录下能看到a.txt\n数据卷的继承\n[root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -it --name=u2 --volumes-from u1 ubuntu Docker安装部署中间件 安装tomcat #拉取镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker pull tomcat  #启动镜像 [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -d --name=t1 -p 8888:8080 tomcat  #tomcat8以上的版本需要把webapps.dist目录下的复制到webapps root@0c4129d634bc:/usr/local/tomcat# rm -rf webapps root@0c4129d634bc:/usr/local/tomcat# mv webapps.dist webapps 访问tomcat\n安装MySQL [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker run -d -p 3306:3306 --name mysql \\  -v /data/mysql/log:/var/log/mysql \\  -v /data/mysql/data:/var/lib/mysql \\  -v /data/mysql/conf:/etc/mysql/conf.d \\  -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7  #进入mysql容器登录mysql [root@iZbp162vx7bwpqiv8pmpdvZ ~]# docker exec -it mysql /bin/bash root@a6bfec31c594:/# mysql -uroot -p Enter password: mysql show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) Dockerfile Dockerfile的概述 Dockerfile 是一种被Docker程序解释的脚本，Dockerfile是由一条条的命令组成的，每条命令对应linux下面的一条命令，Docker程序将这些DockerFile指令再翻译成真正的linux命令，其有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docke镜像，避免了重复手动制作镜像的麻烦，类似与shell脚本一样，可以方便高效的制作镜像。\nDockerfile文件说明  每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写 使用 # 开始作为注释 每一行只支持一条指令，每条指令可以携带多个参数 指令按文件的顺序从上至下执行 每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令  Dockerfile指令介绍    指令 说明     FROM 指定基础镜像   LABEL 指定镜像元数据，如镜像作者   RUN 执行shell命令   COPY 拷贝文件和目录到镜像中   ADD 拷贝文件到镜像中，会自动处理URL和解压   ENV 设置环境变量   USER 指定镜像用什么用户去执行，不指定默认是root   WORKDIR 指定容器的工作目录   EXPOSE 暴露端口   VOLUME 数据卷，用作数据持久化   CMD 容器启动时执行的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被 docker run 之后的参数覆盖   ENTRYPOINT 容器启动时执行的命令。类似于CMD指令，不会被 docker run 之后的参数覆盖，而且这些命令行参数会被当作参数传给 ENTRYPOINT    自定义镜像 Docker网络 Docker-compose容器编排 可视化工具Portainer ","wordCount":"1217","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiayi26.github.io/posts/docker/"},"publisher":{"@type":"Organization","name":"JIAYI's Blog","logo":{"@type":"ImageObject","url":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiayi26.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiayi26.github.io/posts/>Posts</a></div><h1 class=post-title>Docker</h1><div class=post-meta>6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Pass-JIAYI%27s.github.io/post/posts/docker.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=docker的概述>Docker的概述<a hidden class=anchor aria-hidden=true href=#docker的概述>#</a></h3><h4 id=什么是docker>什么是Docker<a hidden class=anchor aria-hidden=true href=#什么是docker>#</a></h4><ul><li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。</li><li>Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。</li><li>Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。</li></ul><h4 id=docker的主要目标>Docker的主要目标<a hidden class=anchor aria-hidden=true href=#docker的主要目标>#</a></h4><p><strong>&ldquo;Build，Ship and Run Any App,Anywhere&rdquo;</strong>，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。</p><h4 id=docker的组成>Docker的组成<a hidden class=anchor aria-hidden=true href=#docker的组成>#</a></h4><ul><li><strong>镜像(Images)</strong>：镜像可以理解为创建实例使用的模板</li><li><strong>容器(Container)</strong>: 容器是从镜像生成对外提供服务的一个或一组服务</li><li><strong>仓库(Registry)</strong>: 保存镜像的仓库，官方仓库: <a href=https://hub.docker.com/>https://hub.docker.com/</a>
<img loading=lazy src=http://www.yunweipai.com/wp-content/uploads/2020/06/engine-components-flow.png alt=logo></li></ul><h4 id=容器和虚拟机的比较>容器和虚拟机的比较<a hidden class=anchor aria-hidden=true href=#容器和虚拟机的比较>#</a></h4><p>容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。</p><p><strong>容器</strong>是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。</p><p><strong>虚拟机</strong> (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。</p><ul><li>资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机</li><li>开销更小：不需要启动单独的虚拟机OS内核占用硬件资源</li><li>启动速度更快：可以在数秒内完成启动</li><li>集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理
<img loading=lazy src=https://www.docker.com/wp-content/uploads/2021/11/docker-containerized-appliction-blue-border_2.png.webp alt=logo>
<img loading=lazy src=https://www.docker.com/wp-content/uploads/2021/11/container-vm-whatcontainer_2.png.webp alt=logo></li></ul><h3 id=docker的安装>Docker的安装<a hidden class=anchor aria-hidden=true href=#docker的安装>#</a></h3><p>官方文档：<a href=https://docs.docker.com/engine/install/centos/>https://docs.docker.com/engine/install/centos/</a>
这里以CentOS7为例</p><h4 id=卸载旧版本>卸载旧版本<a hidden class=anchor aria-hidden=true href=#卸载旧版本>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum remove docker \</span>
</span></span><span style=display:flex><span>&gt;              docker-client <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-client-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-common <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-latest-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-logrotate <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt;              docker-engine
</span></span></code></pre></div><h4 id=设置镜像仓库>设置镜像仓库<a hidden class=anchor aria-hidden=true href=#设置镜像仓库>#</a></h4><p>由于官网的yum源太慢，下面把镜像仓库设置成阿里云的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#安装必要的一些系统工具</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum install -y yum-utils</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#添加阿里云镜像仓库</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#更新yum软件包索引</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum makecache</span>
</span></span></code></pre></div><h4 id=安装启动docker>安装启动Docker<a hidden class=anchor aria-hidden=true href=#安装启动docker>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum install -y docker-ce docker-ce-cli containerd.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl start docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl enable docker</span>
</span></span></code></pre></div><h4 id=验证>验证<a hidden class=anchor aria-hidden=true href=#验证>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#查看版本</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker version</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#hello-world</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run hello-world</span>
</span></span></code></pre></div><p><strong>卸载</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># yum remove docker-ce docker-ce-cli containerd.io</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># rm -rf /var/lib/docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># rm -rf /var/lib/containerd</span>
</span></span></code></pre></div><h4 id=配置阿里云镜像加速>配置阿里云镜像加速<a hidden class=anchor aria-hidden=true href=#配置阿里云镜像加速>#</a></h4><p><a href=https://cr.console.aliyun.com/>https://cr.console.aliyun.com/</a></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230313170820052.png alt=image-20230313170820052></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># mkdir -p /etc/docker</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>&gt;   <span style=color:#e6db74>&#34;registry-mirrors&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;你的加速器地址&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>&gt; EOF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl daemon-reload</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># systemctl restart docker</span>
</span></span></code></pre></div><h3 id=docker常用命令>Docker常用命令<a hidden class=anchor aria-hidden=true href=#docker常用命令>#</a></h3><h4 id=帮助类命令>帮助类命令<a hidden class=anchor aria-hidden=true href=#帮助类命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker &ndash;help</td><td>查看docker帮助文档</td></tr><tr><td>docker 具体命令 &ndash;help</td><td>查看docker具体命令帮助文档</td></tr></tbody></table><h4 id=镜像命令>镜像命令<a hidden class=anchor aria-hidden=true href=#镜像命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker images</td><td>查看本地的镜像</td></tr><tr><td>docker search 镜像名字</td><td>搜索镜像</td></tr><tr><td>docker pull 镜像名字</td><td>拉取镜像</td></tr><tr><td>docker rmi 镜像ID或名字</td><td>删除镜像</td></tr><tr><td>docker system df</td><td>查看镜像、容器、数据卷所占空间</td></tr></tbody></table><h4 id=容器命令>容器命令<a hidden class=anchor aria-hidden=true href=#容器命令>#</a></h4><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>docker run</td><td>启动容器</td></tr><tr><td>docker ps</td><td>当前正在运行的容器</td></tr><tr><td>docker start 容器ID或容器名</td><td>启动已停止运行的容器</td></tr><tr><td>docker restart 容器ID或容器名</td><td>重启容器</td></tr><tr><td>docker stop 容器ID或容器名</td><td>停止容器</td></tr><tr><td>docker kill 容器ID或容器名</td><td>强制停止容器</td></tr><tr><td>docker rm 容器ID或容器名</td><td>删除已停止的容器</td></tr><tr><td>docker logs 容器ID</td><td>查看容器日志</td></tr><tr><td>docker top 容器ID</td><td>查看容器内进程</td></tr><tr><td>docker inspect 容器ID</td><td>查看容器内部细节</td></tr><tr><td>docker cp 容器ID:容器文件路径 目的主机路径</td><td>从容器内拷贝文件到目的主机</td></tr><tr><td>docker export 容器ID > 文件名.tar</td><td>导出容器内容作为一个tar归档文件</td></tr><tr><td>cat 文件名.tar | docker import - 镜像名</td><td>导入镜像</td></tr><tr><td>docker exec -it 容器ID</td><td>进入容器（exit退出，容器不停止）</td></tr><tr><td>docker attach 容器ID</td><td>进入容器（exit退出，容器停止）</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@test_server ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 80:80 --name=mynginx  nginx</span>
</span></span><span style=display:flex><span>-i：交互式
</span></span><span style=display:flex><span>-t：终端
</span></span><span style=display:flex><span>-d：以后台的方式运行容器
</span></span><span style=display:flex><span>-P：随机映射端口
</span></span><span style=display:flex><span>-p：指定映射端口
</span></span><span style=display:flex><span>--name<span style=color:#f92672>=</span>镜像名字：为容器指定一个名字
</span></span><span style=display:flex><span>exit：退出容器，容器停止
</span></span><span style=display:flex><span>ctrl+p+q：退出容器，容器不停止
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230313200613055.png alt=image-20230313200613055></p><table><thead><tr><th>命令</th><th>描述</th><th>解释</th></tr></thead><tbody><tr><td>attach</td><td>Attach to a running container</td><td>当前 shell 下 attach 连接指定运行镜像</td></tr><tr><td>build</td><td>Build an image from a Dockerfile</td><td>通过 Dockerfile 定制镜像</td></tr><tr><td>commit</td><td>Create a new image from a container changes</td><td>提交当前容器为新的镜像</td></tr><tr><td>cp</td><td>Copy files/folders from the containers filesystem to the host path</td><td>从容器中拷贝指定文件或者目录到宿主机中</td></tr><tr><td>create</td><td>Create a new container</td><td>创建一个新的容器，同 run，但不启动容器</td></tr><tr><td>diff</td><td>Inspect changes on a container&rsquo;s filesystem</td><td>查看 docker 容器变化</td></tr><tr><td>events</td><td>Get real time events from the server</td><td>从 docker 服务获取容器实时事件</td></tr><tr><td>exec</td><td>Run a command in an existing container</td><td>在已存在的容器上运行命令</td></tr><tr><td>export</td><td>Stream the contents of a container as a tar archive</td><td>导出容器的内容流作为一个 tar 归档文件[对应 import ]</td></tr><tr><td>history</td><td>Show the history of an image</td><td>展示一个镜像形成历史</td></tr><tr><td>images</td><td>List images</td><td>列出系统当前镜像</td></tr><tr><td>import</td><td>Create a new filesystem image from the contents of a tarball</td><td>从tar包中的内容创建一个新的文件系统映像[对应export]</td></tr><tr><td>info</td><td>Display system-wide information</td><td>显示系统相关信息</td></tr><tr><td>inspect</td><td>Return low-level information on a container</td><td>查看容器详细信息</td></tr><tr><td>kill</td><td>Kill a running container</td><td>kill 指定 docker 容器</td></tr><tr><td>load</td><td>Load an image from a tar archive</td><td>从一个 tar 包中加载一个镜像[对应 save]</td></tr><tr><td>login</td><td>Register or Login to the docker registry server</td><td>注册或者登陆一个 docker 源服务器</td></tr><tr><td>logout</td><td>Log out from a Docker registry server</td><td>从当前 Docker registry 退出</td></tr><tr><td>logs</td><td>Fetch the logs of a container</td><td>输出当前容器日志信息</td></tr><tr><td>port</td><td>Lookup the public-facing port which is NAT-ed to PRIVATE_PORT</td><td>查看映射端口对应的容器内部源端口</td></tr><tr><td>pause</td><td>Pause all processes within a container</td><td>暂停容器</td></tr><tr><td>ps</td><td>List containers</td><td>列出容器列表</td></tr><tr><td>pull</td><td>Pull an image or a repository from the docker registry server</td><td>从docker镜像源服务器拉取指定镜像或者库镜像</td></tr><tr><td>push</td><td>Push an image or a repository to the docker registry server</td><td>推送指定镜像或者库镜像至docker源服务器</td></tr><tr><td>restart</td><td>Restart a running container</td><td>重启运行的容器</td></tr><tr><td>rm</td><td>Remove one or more containers</td><td>移除一个或者多个容器</td></tr><tr><td>rmi</td><td>Remove one or more images</td><td>移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</td></tr><tr><td>run</td><td>Run a command in a new container</td><td>创建一个新的容器并运行一个命令</td></tr><tr><td>save</td><td>Save an image to a tar archive</td><td>保存一个镜像为一个 tar 包[对应 load]</td></tr><tr><td>search</td><td>Search for an image on the Docker Hub</td><td>在 docker hub 中搜索镜像</td></tr><tr><td>start</td><td>Start a stopped containers</td><td>启动容器</td></tr><tr><td>stop</td><td>Stop a running containers</td><td>停止容器</td></tr><tr><td>tag</td><td>Tag an image into a repository</td><td>给源中镜像打标签</td></tr><tr><td>top</td><td>Lookup the running processes of a container</td><td>查看容器中运行的进程信息</td></tr><tr><td>unpause</td><td>Unpause a paused container</td><td>取消暂停容器</td></tr><tr><td>version</td><td>Show the docker version information</td><td>查看 docker 版本号</td></tr><tr><td>wait</td><td>Block until a container stops, then print its exit code</td><td>截取容器停止时的退出状态值</td></tr></tbody></table><h3 id=docker镜像>Docker镜像<a hidden class=anchor aria-hidden=true href=#docker镜像>#</a></h3><h4 id=什么是镜像>什么是镜像<a hidden class=anchor aria-hidden=true href=#什么是镜像>#</a></h4><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><h4 id=unionfs联合文件系统>UnionFS（联合文件系统）<a hidden class=anchor aria-hidden=true href=#unionfs联合文件系统>#</a></h4><p>Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h4 id=docker镜像加载原理>Docker镜像加载原理<a hidden class=anchor aria-hidden=true href=#docker镜像加载原理>#</a></h4><p>Docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/55fc2729cfa3ad893c1d33b3e616645f.png alt=img></p><h3 id=本地镜像发布到阿里云>本地镜像发布到阿里云<a hidden class=anchor aria-hidden=true href=#本地镜像发布到阿里云>#</a></h3><h4 id=本地先生成一个镜像>本地先生成一个镜像<a hidden class=anchor aria-hidden=true href=#本地先生成一个镜像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#原始的ubuntu镜像是不带vim命令的，我们安装vim命令并commit新镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it ubuntu</span>
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# vim a.txt
</span></span><span style=display:flex><span>bash: vim: command not found
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# apt-get update
</span></span><span style=display:flex><span>root@e01aa0b39f6b:/# apt-get -y install vim
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker commit -m=&#34;add cmd vim&#34; -a=&#34;jiayi&#34; e01aa0b39f6b myubuntu:1.1</span>
</span></span><span style=display:flex><span>sha256:b792ae050b8c53e1b02bf98fc547ddf3d4274788c1db15aa922fb872f358b387
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>myubuntu      1.1       b792ae050b8c   <span style=color:#ae81ff>6</span> seconds ago   182MB
</span></span><span style=display:flex><span>ubuntu        latest    ba6acccedd29   <span style=color:#ae81ff>17</span> months ago   72.8MB
</span></span><span style=display:flex><span>hello-world   latest    feb5d9fea6a5   <span style=color:#ae81ff>17</span> months ago   13.3kB
</span></span></code></pre></div><h4 id=推送本地镜像到阿里云>推送本地镜像到阿里云<a hidden class=anchor aria-hidden=true href=#推送本地镜像到阿里云>#</a></h4><p>打开阿里云</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314132105453.png alt=image-20230314132105453></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314131710745.png alt=image-20230314131710745></p><p>点击管理</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#登录阿里云Docker Registry</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker login --username=238y0 registry.cn-hangzhou.aliyuncs.com</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#将镜像推送到Registry</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker tag b792ae050b8c registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker push registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314133317908.png alt=image-20230314133317908></p><h4 id=从阿里云拉取镜像到本地>从阿里云拉取镜像到本地<a hidden class=anchor aria-hidden=true href=#从阿里云拉取镜像到本地>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker pull registry.cn-hangzhou.aliyuncs.com/23y/myubuntu:1.1</span>
</span></span></code></pre></div><h3 id=本地镜像发布到私有仓库>本地镜像发布到私有仓库<a hidden class=anchor aria-hidden=true href=#本地镜像发布到私有仓库>#</a></h3><h4 id=harbor镜像仓库安装及使用>Harbor镜像仓库安装及使用<a hidden class=anchor aria-hidden=true href=#harbor镜像仓库安装及使用>#</a></h4><p><strong>Harbor简介</strong></p><p>Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很多优势：</p><ul><li><p>提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定传输的对象。</p></li><li><p>提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界面可以支持登陆、搜索功能，包括区分公有、私有镜像。</p></li><li><p>支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分解。</p></li><li><p>良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限，具有更好的安全性。</p></li></ul><p><strong>Harbor的安装</strong></p><p><strong>先安装docker-compose</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># curl -L &#34;https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-$(uname -s)-$(uname -m)&#34; -o /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#给docker-compose添加执行权限</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># chmod +x /usr/local/bin/docker-compose</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose -v</span>
</span></span><span style=display:flex><span>Docker Compose version v2.16.0
</span></span></code></pre></div><p>下载Harbor的压缩包<a href=https://github.com/goharbor/harbor/releases>https://github.com/goharbor/harbor/releases</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#上传到linux服务器并解压</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># tar -zxf harbor-offline-installer-v1.10.17.tgz</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># mv harbor /opt/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#修改 harbor.yml，注释掉下面的四行</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># vi harbor.yml</span>
</span></span><span style=display:flex><span>hostname: 192.168.66.102
</span></span><span style=display:flex><span>port: <span style=color:#ae81ff>85</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#https:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  port: 443</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  certificate: /your/certificate/path</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  private_key: /your/private/key/path</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#安装harbor</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># ./prepare</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># ./install.sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#启动harbor</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker-compose up -d</span>
</span></span></code></pre></div><p><strong>访问Harbor</strong></p><p>默认密码：Harbor12345</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314143949118.png alt=image-20230314143949118></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144147296.png alt=image-20230314144147296></p><p><strong>新建项目、创建用户</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144329226.png alt=image-20230314144329226></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314144801725.png alt=image-20230314144801725></p><p><strong>给私有项目分配用户</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314145023809.png alt=image-20230314145023809></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314145204624.png alt=image-20230314145204624></p><ul><li>访客：对于指定项目拥有只读权限</li><li>开发人员：对于指定项目拥有读写权限</li><li>维护人员：对于指定项目拥有读写权限，创建 Webhooks</li><li>项目管理员：除了读写权限，同时拥有用户管理/镜像扫描等管理权限</li></ul><h4 id=把镜像上传到harbor>把镜像上传到Harbor<a hidden class=anchor aria-hidden=true href=#把镜像上传到harbor>#</a></h4><p><strong>把Harbor地址加入到Docker信任列表</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># vi /etc/docker/daemon.json</span>
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;registry-mirrors&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;https://5wr347bg.mirror.aliyuncs.com&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;insecure-registries&#34;</span>:<span style=color:#f92672>[</span><span style=color:#e6db74>&#34;121.40.217.66:85&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># systemctl daemon-reload</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># systemctl restart docker</span>
</span></span></code></pre></div><p><strong>登录Harbor</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker images</span>
</span></span><span style=display:flex><span>REPOSITORY       TAG        IMAGE ID       CREATED         SIZE
</span></span><span style=display:flex><span>myubuntu         1.1        a558d68de60a   <span style=color:#ae81ff>9</span> seconds ago   182MB
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker login -u 用户名 -p 密码 121.40.217.66:85
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#给镜像打标签</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker tag a558d68de60a 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#推送镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker push 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314154239997.png alt=image-20230314154239997></p><h4 id=从harbor上拉取镜像>从Harbor上拉取镜像<a hidden class=anchor aria-hidden=true href=#从harbor上拉取镜像>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker pull 121.40.217.66:85/ops/myubuntu:1.1</span>
</span></span></code></pre></div><h3 id=docker容器数据卷>Docker容器数据卷<a hidden class=anchor aria-hidden=true href=#docker容器数据卷>#</a></h3><h4 id=数据卷是什么>数据卷是什么<a hidden class=anchor aria-hidden=true href=#数据卷是什么>#</a></h4><p>数据卷（Data Volumes）是宿主机中的一个目录或文件，数据卷的设计目的就是<strong>数据的持久化</strong>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><h4 id=为什么要用数据卷>为什么要用数据卷<a hidden class=anchor aria-hidden=true href=#为什么要用数据卷>#</a></h4><p>Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。</p><p>数据卷的特点：</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><h4 id=数据卷的基本使用>数据卷的基本使用<a hidden class=anchor aria-hidden=true href=#数据卷的基本使用>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#创建数据卷</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume create mydata</span>
</span></span><span style=display:flex><span>mydata
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#列出所有数据卷</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume ls</span>
</span></span><span style=display:flex><span>DRIVER    VOLUME NAME
</span></span><span style=display:flex><span>local     mydata
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看数据卷信息</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ harbor<span style=color:#f92672>]</span><span style=color:#75715e># docker volume inspect mydata</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CreatedAt&#34;</span>: <span style=color:#e6db74>&#34;2023-03-14T16:36:47+08:00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Driver&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Labels&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mountpoint&#34;</span>: <span style=color:#e6db74>&#34;/var/lib/docker/volumes/mydata/_data&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;mydata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Options&#34;</span>: null,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Scope&#34;</span>: <span style=color:#e6db74>&#34;local&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>容器和宿主机之间数据共享</strong></p><p>用 docker run 启动一个容器</p><p>-v &lt;宿主机目录或文件>:&lt;容器目录或文件>[:ro] #目录会自动创建</p><p>:ro 此项为只读，不写此项默认为可读可写</p><p>举例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it --name=u1 -v /tmp/hostdata:/tmp/dockerdata ubuntu</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker ps -n2</span>
</span></span><span style=display:flex><span>CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS           PORTS     NAMES
</span></span><span style=display:flex><span>8b2cd2892e82   ubuntu    <span style=color:#e6db74>&#34;bash&#34;</span>    <span style=color:#ae81ff>35</span> minutes ago   Up <span style=color:#ae81ff>18</span> minutes              u1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#查看挂在目录</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker inspect 8b2cd2892e82</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Mounts&#34;</span>: <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Type&#34;</span>: <span style=color:#e6db74>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Source&#34;</span>: <span style=color:#e6db74>&#34;/tmp/hostdata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Destination&#34;</span>: <span style=color:#e6db74>&#34;/tmp/dockerdata&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Mode&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;RW&#34;</span>: true,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Propagation&#34;</span>: <span style=color:#e6db74>&#34;rprivate&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>,
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314172427107.png alt=image-20230314172427107></p><p>把容器停掉，在宿主机的/tmp/hostdata目录下新建a.txt文件，重新启动容器后在容器的/tmp/dockerdata目录下能看到a.txt</p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314173553136.png alt=image-20230314173553136></p><p><strong>数据卷的继承</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -it --name=u2 --volumes-from u1 ubuntu</span>
</span></span></code></pre></div><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314180420410.png alt=image-20230314180420410></p><h3 id=docker安装部署中间件>Docker安装部署中间件<a hidden class=anchor aria-hidden=true href=#docker安装部署中间件>#</a></h3><h4 id=安装tomcat>安装tomcat<a hidden class=anchor aria-hidden=true href=#安装tomcat>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#拉取镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker pull tomcat</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#启动镜像</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d --name=t1 -p 8888:8080 tomcat</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#tomcat8以上的版本需要把webapps.dist目录下的复制到webapps</span>
</span></span><span style=display:flex><span>root@0c4129d634bc:/usr/local/tomcat# rm -rf webapps
</span></span><span style=display:flex><span>root@0c4129d634bc:/usr/local/tomcat# mv webapps.dist webapps
</span></span></code></pre></div><p><strong>访问tomcat</strong></p><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20230314193640896.png alt=image-20230314193640896></p><h4 id=安装mysql>安装MySQL<a hidden class=anchor aria-hidden=true href=#安装mysql>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker run -d -p 3306:3306 --name mysql \</span>
</span></span><span style=display:flex><span>&gt; -v /data/mysql/log:/var/log/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -v /data/mysql/data:/var/lib/mysql <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -v /data/mysql/conf:/etc/mysql/conf.d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>&gt; -e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> mysql:5.7
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#进入mysql容器登录mysql</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>root@iZbp162vx7bwpqiv8pmpdvZ ~<span style=color:#f92672>]</span><span style=color:#75715e># docker exec -it mysql /bin/bash</span>
</span></span><span style=display:flex><span>root@a6bfec31c594:/# mysql -uroot -p
</span></span><span style=display:flex><span>Enter password: 
</span></span><span style=display:flex><span>mysql&gt; show databases;
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span>| Database           |
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span>| information_schema |
</span></span><span style=display:flex><span>| mysql              |
</span></span><span style=display:flex><span>| performance_schema |
</span></span><span style=display:flex><span>| sys                |
</span></span><span style=display:flex><span>+--------------------+
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> rows in set <span style=color:#f92672>(</span>0.00 sec<span style=color:#f92672>)</span>
</span></span></code></pre></div><h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3><h4 id=dockerfile的概述>Dockerfile的概述<a hidden class=anchor aria-hidden=true href=#dockerfile的概述>#</a></h4><p>Dockerfile 是一种被Docker程序解释的脚本，Dockerfile是由一条条的命令组成的，每条命令对应linux下面的一条命令，Docker程序将这些DockerFile指令再翻译成真正的linux命令，其有自己的书写方式和支持的命令，Docker程序读取Dockerfile并根据指令生成Docker镜像，相比手动制作镜像的方式，Dockerfile更能直观的展示镜像是怎么产生的，有了Dockerfile，当后期有额外的需求时，只要在之前的Dockerfile添加或者修改响应的命令即可重新生成新的Docke镜像，避免了重复手动制作镜像的麻烦，类似与shell脚本一样，可以方便高效的制作镜像。</p><h4 id=dockerfile文件说明>Dockerfile文件说明<a hidden class=anchor aria-hidden=true href=#dockerfile文件说明>#</a></h4><ul><li>每一行以Dockerfile的指令开头，指令不区分大小写，但是惯例使用大写</li><li>使用 # 开始作为注释</li><li>每一行只支持一条指令，每条指令可以携带多个参数</li><li>指令按文件的顺序从上至下执行</li><li>每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令</li></ul><h4 id=dockerfile指令介绍>Dockerfile指令介绍<a hidden class=anchor aria-hidden=true href=#dockerfile指令介绍>#</a></h4><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>LABEL</td><td>指定镜像元数据，如镜像作者</td></tr><tr><td>RUN</td><td>执行shell命令</td></tr><tr><td>COPY</td><td>拷贝文件和目录到镜像中</td></tr><tr><td>ADD</td><td>拷贝文件到镜像中，会自动处理URL和解压</td></tr><tr><td>ENV</td><td>设置环境变量</td></tr><tr><td>USER</td><td>指定镜像用什么用户去执行，不指定默认是root</td></tr><tr><td>WORKDIR</td><td>指定容器的工作目录</td></tr><tr><td>EXPOSE</td><td>暴露端口</td></tr><tr><td>VOLUME</td><td>数据卷，用作数据持久化</td></tr><tr><td>CMD</td><td>容器启动时执行的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被 docker run 之后的参数覆盖</td></tr><tr><td>ENTRYPOINT</td><td>容器启动时执行的命令。类似于CMD指令，不会被 docker run 之后的参数覆盖，而且这些命令行参数会被当作参数传给 ENTRYPOINT</td></tr></tbody></table><p><img loading=lazy src=https://gitee.com/JIAYI233/kabu/raw/master/image-20200223161407333-780x374.png alt=docker-dockerfile指令详细介绍插图></p><h4 id=自定义镜像>自定义镜像<a hidden class=anchor aria-hidden=true href=#自定义镜像>#</a></h4><h3 id=docker网络>Docker网络<a hidden class=anchor aria-hidden=true href=#docker网络>#</a></h3><h3 id=docker-compose容器编排>Docker-compose容器编排<a hidden class=anchor aria-hidden=true href=#docker-compose容器编排>#</a></h3><h3 id=可视化工具portainer>可视化工具Portainer<a hidden class=anchor aria-hidden=true href=#可视化工具portainer>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiayi26.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://jiayi26.github.io/posts/kubernetes%E7%BB%84%E4%BB%B6/><span class=title>« Prev Page</span><br><span>Kubernetes组件</span></a>
<a class=next href=https://jiayi26.github.io/posts/%E7%AC%AC07%E7%AB%A0-innodb%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/><span class=title>Next Page »</span><br><span>InnoDB数据存储结构</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker on twitter" href="https://twitter.com/intent/tweet/?text=Docker&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&hashtags=Docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&title=Docker&summary=Docker&source=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f&title=Docker"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20-%20https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker on telegram" href="https://telegram.me/share/url?text=Docker&url=https%3a%2f%2fjiayi26.github.io%2fposts%2fdocker%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>