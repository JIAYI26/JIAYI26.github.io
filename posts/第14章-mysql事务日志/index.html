<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySQL事务日志 | JIAYI's Blog</title><meta name=keywords content="MySQL"><meta name=description content="第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？
 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。
1.2 REDO日志的好处、特点 1. 好处
 redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点
 redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：
 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：
redo log buffer 大小，默认16M，最大值是4096M，最小值为1M。
 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="MySQL事务日志"><meta property="og:description" content="第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？
 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。
1.2 REDO日志的好处、特点 1. 好处
 redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点
 redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：
 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：
redo log buffer 大小，默认16M，最大值是4096M，最小值为1M。
 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值"><meta property="og:type" content="article"><meta property="og:url" content="https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"><meta property="article:section" content="posts"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="MySQL事务日志"><meta name=twitter:description content="第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？
 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。
另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。
那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题
另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。
1.2 REDO日志的好处、特点 1. 好处
 redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点
 redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：
 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：
redo log buffer 大小，默认16M，最大值是4096M，最小值为1M。
 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝
第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiayi26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"MySQL事务日志","item":"https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySQL事务日志","name":"MySQL事务日志","description":"第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？\n 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。\n另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。\n那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题\n另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。\n1.2 REDO日志的好处、特点 1. 好处\n redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点\n redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：\n 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：\nredo log buffer 大小，默认16M，最大值是4096M，最小值为1M。\n 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝\n第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值","keywords":["MySQL"],"articleBody":"第14章 MySQL事务日志 事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？\n 事务的隔离性由锁机制实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。 UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    1. redo日志 1.1 为什么需要REDO日志 一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。\n另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。\n那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题\n另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。\n1.2 REDO日志的好处、特点 1. 好处\n redo日志降低了刷盘频率 redo日志占用的空间非常小  2. 特点\n redo日志是顺序写入磁盘的 事务执行过程中，redo log不断记录  1.3 redo的组成 Redo log可以简单分为以下两个部分：\n 重做日志的缓冲 (redo log buffer) ，保存在内存中，是易失的。  参数设置：innodb_log_buffer_size：\nredo log buffer 大小，默认16M，最大值是4096M，最小值为1M。\n 重做日志文件 (redo log file)，保存在硬盘中，是持久的。  1.4 redo的整体流程 第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝\n第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值\n第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式\n第4步：定期将内存中修改的数据刷新到磁盘中\n Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。\n 1.5 redo log的刷盘策略 redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。\n针对这种情况，InnoDB给出innodb_flush_log_at_trx_commit参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：\n 设置为0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步） 设置为1：表示每次事务提交时都将进行同步，刷盘操作（默认值） 设置为2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。  1.6 不同刷盘策略演示 1. 流程图\n1.7 写入redo log buffer过程 1. 补充概念：Mini-Transaction\n一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志\n2. redo 日志写入log buffer\n不同的事务可能是并发执行的，所以事务T1、事务T2之间的mtr可能是交替执行的。\n1.8 redo log file 1. 相关参数设置\n  innodb_log_group_home_dir：指定 redo log 文件组所在的路径，默认值为./，表示在数据库的数据目录下。MySQL的默认数据目录（var/lib/mysql）下默认有两个名为ib_logfile0和ib_logfile1的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。\n  innodb_log_files_in_group：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认2个，最大100个。\n  innodb_flush_log_at_trx_commit：控制 redo log 刷新到磁盘的策略，默认为1。\n  innodb_log_file_size：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。\n  2. 日志文件组\n3. checkpoint\n如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。\n2. Undo日志 redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要先写入一个 undo log 。\n2.1 如何理解Undo日志 事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：\n 情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。 情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。  以上情况出现，我们需要把数据改回原先的样子，这个过程称之为回滚，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。\n2.2 Undo日志的作用  作用1：回滚数据 作用2：MVCC（详情看第16章）  2.3 undo的存储结构 1. 回滚段与undo页\nInnoDB对undo log的管理采用段的方式，也就是回滚段（rollback segment）。每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo页的申请。\n2. 回滚段与事务\n  每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。\n  当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。\n  在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。\n  回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。\n  当事务提交时，InnoDB存储引擎会做以下两件事情：\n 将undo log放入列表中，以供之后的purge操作 判断undo log所在的页是否可以重用，若可以分配给下个事务使用    3. 回滚段中的数据分类\n  未提交的回滚数据(uncommitted undo information)\n  已经提交但未过期的回滚数据(committed undo information)\n  事务已经提交并过期的数据(expired undo information)\n  2.4 undo的类型 在InnoDB存储引擎中，undo log分为：\n insert undo log update undo log  2.5 undo log的生命周期 1. 简要生成过程\n只有Buffer Pool的流程：\n有了Redo Log和Undo Log之后：\n2. 详细生成过程\n当我们执行INSERT时：\nbegin; INSERT INTO user (name) VALUES (\"tom\"); 当我们执行UPDATE时：\nUPDATE user SET id=2 WHERE id=1; 3. undo log是如何回滚的\n以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：\n  通过undo no=3的日志把id=2的数据删除\n  通过undo no=2的日志把id=1的数据的deletemark还原成0\n  通过undo no=1的日志把id=1的数据的name还原成Tom\n  通过undo no=0的日志把id=1的数据删除\n  4. undo log的删除\n 针对于insert undo log  因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。\n 针对于update undo log  该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。\n2.6 小结 undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。\nredo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。\n","wordCount":"285","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiayi26.github.io/posts/%E7%AC%AC14%E7%AB%A0-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"},"publisher":{"@type":"Organization","name":"JIAYI's Blog","logo":{"@type":"ImageObject","url":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiayi26.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiayi26.github.io/posts/>Posts</a></div><h1 class=post-title>MySQL事务日志</h1><div class=post-meta>2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Pass-JIAYI%27s.github.io/post/posts/%e7%ac%ac14%e7%ab%a0%20MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=第14章-mysql事务日志>第14章 MySQL事务日志<a hidden class=anchor aria-hidden=true href=#第14章-mysql事务日志>#</a></h3><p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><h4 id=1-redo日志><strong>1. redo日志</strong><a hidden class=anchor aria-hidden=true href=#1-redo日志>#</a></h4><h5 id=11-为什么需要redo日志><strong>1.1</strong> <strong>为什么需要REDO日志</strong><a hidden class=anchor aria-hidden=true href=#11-为什么需要redo日志>#</a></h5><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把<code>修改</code>了哪些东西<code>记录一下</code>就好。比如，某个事务将系统表空间中<code>第10号</code>页面中偏移量为<code>100</code>处的那个字节的值<code>1</code>改成<code>2</code>。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p><h5 id=12-redo日志的好处特点><strong>1.2 REDO日志的好处、特点</strong><a hidden class=anchor aria-hidden=true href=#12-redo日志的好处特点>#</a></h5><p><strong>1.</strong> <strong>好处</strong></p><ul><li><strong>redo日志降低了刷盘频率</strong></li><li><strong>redo日志占用的空间非常小</strong></li></ul><p><strong>2.</strong> <strong>特点</strong></p><ul><li><strong>redo日志是顺序写入磁盘的</strong></li><li><strong>事务执行过程中，redo log不断记录</strong></li></ul><h5 id=13-redo的组成><strong>1.3 redo的组成</strong><a hidden class=anchor aria-hidden=true href=#13-redo的组成>#</a></h5><p>Redo log可以简单分为以下两个部分：</p><ul><li><code>重做日志的缓冲 (redo log buffer) </code>，保存在内存中，是易失的。</li></ul><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。</p><ul><li><code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</li></ul><h5 id=14-redo的整体流程><strong>1.4 redo的整体流程</strong><a hidden class=anchor aria-hidden=true href=#14-redo的整体流程>#</a></h5><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031147714.png alt=image-20220403114709581></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</p><p>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p><p>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式</p><p>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h5 id=15-redo-log的刷盘策略><strong>1.5 redo log的刷盘策略</strong><a hidden class=anchor aria-hidden=true href=#15-redo-log的刷盘策略>#</a></h5><p>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存</code>（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li><li><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>）</li><li><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</li></ul><h5 id=16-不同刷盘策略演示><strong>1.6</strong> <strong>不同刷盘策略演示</strong><a hidden class=anchor aria-hidden=true href=#16-不同刷盘策略演示>#</a></h5><p><strong>1.</strong> <strong>流程图</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152952.png alt=image-20220403115232833></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031152607.png alt=image-20220403115249492></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204031153931.png alt=image-20220403115300809></p><h5 id=17-写入redo-log-buffer过程><strong>1.7</strong> <strong>写入redo log buffer过程</strong><a hidden class=anchor aria-hidden=true href=#17-写入redo-log-buffer过程>#</a></h5><p><strong>1.</strong> <strong>补充概念：Mini-Transaction</strong></p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条redo日志</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040912119.png alt=image-20220404091224993></p><p><strong>2. redo</strong> <strong>日志写入log buffer</strong></p><p>不同的事务可能是<code>并发</code>执行的，所以<code>事务T1</code>、<code>事务T2</code>之间的<code>mtr</code>可能是<code>交替执行</code>的。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040915708.png alt=image-20220404091511602></p><h5 id=18-redo-log-file><strong>1.8 redo log file</strong><a hidden class=anchor aria-hidden=true href=#18-redo-log-file>#</a></h5><p><strong>1.</strong> <strong>相关参数设置</strong></p><ul><li><p><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</p></li><li><p><code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，ib_logfile1&mldr; ib_logfilen。默认2个，最大100个。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为<code>1</code>。</p></li><li><p><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G。</p></li></ul><p><strong>2.</strong> <strong>日志文件组</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040920532.png alt=image-20220404092038421></p><p><strong>3. checkpoint</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040921715.png alt=image-20220404092106617></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><h4 id=2-undo日志><strong>2. Undo日志</strong><a hidden class=anchor aria-hidden=true href=#2-undo日志>#</a></h4><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 undo log 。</p><h5 id=21-如何理解undo日志><strong>2.1</strong> <strong>如何理解Undo日志</strong><a hidden class=anchor aria-hidden=true href=#21-如何理解undo日志>#</a></h5><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><h5 id=22-undo日志的作用><strong>2.2 Undo日志的作用</strong><a hidden class=anchor aria-hidden=true href=#22-undo日志的作用>#</a></h5><ul><li><strong>作用1：回滚数据</strong></li><li><strong>作用2：MVCC（详情看第16章）</strong></li></ul><h5 id=23-undo的存储结构><strong>2.3 undo的存储结构</strong><a hidden class=anchor aria-hidden=true href=#23-undo的存储结构>#</a></h5><p><strong>1.</strong> <strong>回滚段与undo页</strong></p><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><p><strong>2.</strong> <strong>回滚段与事务</strong></p><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</p></li><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><p><strong>3.</strong> <strong>回滚段中的数据分类</strong></p><ol><li><p>未提交的回滚数据(uncommitted undo information)</p></li><li><p>已经提交但未过期的回滚数据(committed undo information)</p></li><li><p>事务已经提交并过期的数据(expired undo information)</p></li></ol><h5 id=24-undo的类型><strong>2.4 undo的类型</strong><a hidden class=anchor aria-hidden=true href=#24-undo的类型>#</a></h5><p>在InnoDB存储引擎中，undo log分为：</p><ul><li>insert undo log</li><li>update undo log</li></ul><h5 id=25-undo-log的生命周期><strong>2.5 undo log的生命周期</strong><a hidden class=anchor aria-hidden=true href=#25-undo-log的生命周期>#</a></h5><p><strong>1.</strong> <strong>简要生成过程</strong></p><p><strong>只有Buffer Pool的流程：</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040937761.png alt=image-20220404093706650></p><p><strong>有了Redo Log和Undo Log之后：</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040938657.png alt=image-20220404093832512></p><p><strong>2.</strong> <strong>详细生成过程</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040939231.png alt=image-20220404093950136></p><p><strong>当我们执行INSERT时：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>begin; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> <span style=color:#66d9ef>user</span> (name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#34;tom&#34;</span>);
</span></span></code></pre></div><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040940543.png alt=image-20220404094033441></p><p><strong>当我们执行UPDATE时：</strong></p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941624.png alt=image-20220404094105525></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>UPDATE</span> <span style=color:#66d9ef>user</span> <span style=color:#66d9ef>SET</span> id<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> <span style=color:#66d9ef>WHERE</span> id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040941449.png alt=image-20220404094142337></p><p><strong>3. undo log是如何回滚的</strong></p><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li><p>通过undo no=3的日志把id=2的数据删除</p></li><li><p>通过undo no=2的日志把id=1的数据的deletemark还原成0</p></li><li><p>通过undo no=1的日志把id=1的数据的name还原成Tom</p></li><li><p>通过undo no=0的日志把id=1的数据删除</p></li></ol><p><strong>4. undo log的删除</strong></p><ul><li>针对于insert undo log</li></ul><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p><ul><li>针对于update undo log</li></ul><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p><h5 id=26-小结><strong>2.6</strong> <strong>小结</strong><a hidden class=anchor aria-hidden=true href=#26-小结>#</a></h5><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204040944948.png alt=image-20220404094436830></p><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiayi26.github.io/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=https://jiayi26.github.io/posts/linux%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/><span class=title>« Prev Page</span><br><span>Linux性能分析工具</span></a>
<a class=next href=https://jiayi26.github.io/posts/%E7%AC%AC02%E7%AB%A0-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/><span class=title>Next Page »</span><br><span>MySQL的数据目录</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on twitter" href="https://twitter.com/intent/tweet/?text=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f&hashtags=MySQL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f&title=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97&summary=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97&source=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f&title=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on whatsapp" href="https://api.whatsapp.com/send?text=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97%20-%20https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share MySQL事务日志 on telegram" href="https://telegram.me/share/url?text=MySQL%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC14%25E7%25AB%25A0-mysql%25E4%25BA%258B%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>