<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据库的设计规范 | JIAYI's Blog</title><meta name=keywords content="MySQL"><meta name=description content="第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
1.3 键和相关属性的概念 这里有两个表：
球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team)：球队编号 | 主教练 | 球队所在地
 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。
1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&#34;A&ndash;>B&ndash;>C&#34;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。
1.7 小结 关于数据表的设计，有三个范式要遵循。
（1）第一范式（1NF），确保每列保持原子性
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
（2）第二范式（2NF），确保每列都和主键完全依赖
尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。
（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关
**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。
范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。
2. 反范式化 2.1 概述 规范化 vs 性能
  为满足某种商业目标 , 数据库性能比规范化数据库更重要"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="数据库的设计规范"><meta property="og:description" content="第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
1.3 键和相关属性的概念 这里有两个表：
球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team)：球队编号 | 主教练 | 球队所在地
 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。
1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&#34;A&ndash;>B&ndash;>C&#34;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。
1.7 小结 关于数据表的设计，有三个范式要遵循。
（1）第一范式（1NF），确保每列保持原子性
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
（2）第二范式（2NF），确保每列都和主键完全依赖
尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。
（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关
**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。
范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。
2. 反范式化 2.1 概述 规范化 vs 性能
  为满足某种商业目标 , 数据库性能比规范化数据库更重要"><meta property="og:type" content="article"><meta property="og:url" content="https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"><meta property="article:section" content="posts"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据库的设计规范"><meta name=twitter:description content="第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。
1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
1.3 键和相关属性的概念 这里有两个表：
球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team)：球队编号 | 主教练 | 球队所在地
 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。
1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。
1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在&#34;A&ndash;>B&ndash;>C&#34;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。
1.7 小结 关于数据表的设计，有三个范式要遵循。
（1）第一范式（1NF），确保每列保持原子性
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。
（2）第二范式（2NF），确保每列都和主键完全依赖
尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。
（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关
**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。
**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。
范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。
2. 反范式化 2.1 概述 规范化 vs 性能
  为满足某种商业目标 , 数据库性能比规范化数据库更重要"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiayi26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"数据库的设计规范","item":"https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库的设计规范","name":"数据库的设计规范","description":"第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。\n1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n1.3 键和相关属性的概念 这里有两个表：\n球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号\n球队表(team)：球队编号 | 主教练 | 球队所在地\n 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。\n1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。\n1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在\u0026quot;A\u0026ndash;\u0026gt;B\u0026ndash;\u0026gt;C\u0026quot;的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。\n1.7 小结 关于数据表的设计，有三个范式要遵循。\n（1）第一范式（1NF），确保每列保持原子性\n数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。\n（2）第二范式（2NF），确保每列都和主键完全依赖\n尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。\n（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关\n**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。\n**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。\n范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。\n2. 反范式化 2.1 概述 规范化 vs 性能\n  为满足某种商业目标 , 数据库性能比规范化数据库更重要","keywords":["MySQL"],"articleBody":"第11章 数据库的设计规范 1. 范 式 1.1 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。\n1.2 范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n1.3 键和相关属性的概念 这里有两个表：\n球员表(player)：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号\n球队表(team)：球队编号 | 主教练 | 球队所在地\n 超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键：球员表中的球队编号。 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  1.4 第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单位。\n1.5 第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。\n1.6 第三范式(3rd NF) 第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在\"A–B–C\"的决定关系）通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。\n1.7 小结 关于数据表的设计，有三个范式要遵循。\n（1）第一范式（1NF），确保每列保持原子性\n数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。\n（2）第二范式（2NF），确保每列都和主键完全依赖\n尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。\n（3）第三范式（3NF），确保每列都和主键直接相关，而不是间接相关\n**范式的优点：**数据的标准化有助于消除数据库中的数据冗余，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。\n**范式的缺点：**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。\n范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。\n2. 反范式化 2.1 概述 规范化 vs 性能\n  为满足某种商业目标 , 数据库性能比规范化数据库更重要\n  在数据规范化的同时 , 要综合考虑数据库的性能\n  通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间\n  通过在给定的表中插入计算列，以方便查询\n  2.2 反范式的新问题  存储空间变大了 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源 在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂  2.3 反范式的适用场景 当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。\n1. 增加冗余字段的建议\n1）这个冗余字段不需要经常进行修改\n2）这个冗余字段查询的时候不可或缺\n2. 历史快照、历史数据的需要\n在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。\n反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。\n3. BCNF(巴斯范式) 主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。\n如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-Y，Y为主属性，则该关系不属于BCNF。\n4. ER模型 ER模型也叫做实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。\n4.1 ER 模型包括那些要素？ ER 模型中有三个要素，分别是实体、属性和关系。\n实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。\n属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用椭圆形来表示。\n关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。\n注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，可以独立存在的是实体，不可再分的是属性。也就是说，属性不能包含其他属性。\n4.2 关系的类型 在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。\n一对一：指实体之间的关系是一一对应的\n一对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体\n多对多：指关系两边的实体都可以通过关系对应多个对方的实体\n5. 数据表的设计原则 数据表设计的一般原则：“三少一多”\n1. 数据表的个数越少越好\n2. 数据表中的字段个数越少越好\n3. 数据表中联合主键的字段个数越少越好\n4. 使用主键和外键越多越好\n 注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。\n 6. 数据库对象编写建议 6.1 关于库   【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。\n  【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意。\n  【强制】库的名称格式：业务系统名称_子系统名。\n  【强制】库名禁止使用关键字（如type,order等）。\n  【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET 'utf8';\n  【建议】对于程序连接数据库账号，遵循权限最小原则。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限。\n  【建议】临时库以tmp_为前缀，并以日期为后缀；备份库以bak_为前缀，并以日期为后缀。\n  6.2 关于表、列   【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以英文字母开头。\n  【强制】 表名、列名一律小写，不同单词采用下划线分割。须见名知意。\n  【强制】表名要求有模块名强相关，同一模块的表名尽量使用统一前缀。比如：crm_fund_item\n  【强制】创建表时必须显式指定字符集为utf8或utf8mb4。\n  【强制】表名、列名禁止使用关键字（如type,order等）。\n  【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为InnoDB。\n  【强制】建表必须有comment。\n  【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。\n  【强制】布尔值类型的字段命名为is_描述。如member表上表示是否为enabled的会员的字段命名为 is_enabled。\n  【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。\n  【建议】建表时关于主键：表必须有主键 (1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。\n  【建议】核心表（如用户表）必须有行数据的创建时间字段（create_time）和最后更新时间字段（update_time），便于查问题。\n  【建议】表中所有字段尽量都是NOT NULL属性，业务可以根据需要定义DEFAULT值。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。\n  【建议】所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。\n  【建议】中间表（或临时表）用于保留中间结果集，名称以tmp_开头。备份表用于备份或抓取源表快照，名称以bak_开头。中间表和备份表定期清理。\n  【示范】一个较为规范的建表语句：\n  CREATE TABLE user_info (  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',  `user_id` bigint(11) NOT NULL COMMENT '用户id',  `username` varchar(45) NOT NULL COMMENT '真实姓名',  `email` varchar(30) NOT NULL COMMENT '用户邮箱',  `nickname` varchar(45) NOT NULL COMMENT '昵称',  `birthday` date NOT NULL COMMENT '生日',  `sex` tinyint(4) DEFAULT '0' COMMENT '性别',  `short_introduce` varchar(150) DEFAULT NULL COMMENT '一句话介绍自己，最多50个汉字',  `user_resume` varchar(300) NOT NULL COMMENT '用户提交的简历存放地址',  `user_register_ip` int NOT NULL COMMENT '用户注册时的源ip',  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',  `user_review_status` tinyint NOT NULL COMMENT '用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核',  PRIMARY KEY (`id`),  UNIQUE KEY `uniq_user_id` (`user_id`),  KEY `idx_username`(`username`),  KEY `idx_create_time_status`(`create_time`,`user_review_status`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站用户基本信息' 【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。  6.3 关于索引   【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值禁止被更新。\n  【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE。\n  【建议】主键的名称以pk_开头，唯一键以uni_或uk_开头，普通索引以idx_开头，一律使用小写格式，以字段的名称或缩写作为后缀。\n  【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。\n  【建议】单个表上的索引个数不能超过6个。\n  【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。\n  【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。\n  【建议】建表或加索引时，保证表里互相不存在冗余索引。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。\n  6.4 SQL编写   【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。\n  【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。\n  【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。\n  【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。\n  【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。\n  【建议】线上环境，多表 JOIN 不要超过5个表。\n  【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。\n  【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。\n  【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。\n  【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。\n  【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。\n  【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。\n  ","wordCount":"356","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiayi26.github.io/posts/%E7%AC%AC11%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},"publisher":{"@type":"Organization","name":"JIAYI's Blog","logo":{"@type":"ImageObject","url":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiayi26.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiayi26.github.io/posts/>Posts</a></div><h1 class=post-title>数据库的设计规范</h1><div class=post-meta>2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Pass-JIAYI%27s.github.io/post/posts/%e7%ac%ac11%e7%ab%a0%20%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=第11章-数据库的设计规范>第11章 数据库的设计规范<a hidden class=anchor aria-hidden=true href=#第11章-数据库的设计规范>#</a></h3><h4 id=1-范-式><strong>1.</strong> <strong>范 式</strong><a hidden class=anchor aria-hidden=true href=#1-范-式>#</a></h4><h5 id=11-范式简介><strong>1.1</strong> <strong>范式简介</strong><a hidden class=anchor aria-hidden=true href=#11-范式简介>#</a></h5><p>**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的<code>级别</code>。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h5 id=12-范式都包括哪些><strong>1.2</strong> <strong>范式都包括哪些</strong><a hidden class=anchor aria-hidden=true href=#12-范式都包括哪些>#</a></h5><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）</strong>。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204030928295.png alt=image-20220403092826169></p><h5 id=13-键和相关属性的概念><strong>1.3</strong> <strong>键和相关属性的概念</strong><a hidden class=anchor aria-hidden=true href=#13-键和相关属性的概念>#</a></h5><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li><code>超键</code>：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li><li><code>候选键</code>：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li><code>主键</code>：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li><code>外键</code>：球员表中的球队编号。</li><li><code>主属性</code>、<code>非主属性</code>：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li></ul><h5 id=14-第一范式1st-nf><strong>1.4</strong> <strong>第一范式(1st NF)</strong><a hidden class=anchor aria-hidden=true href=#14-第一范式1st-nf>#</a></h5><p>第一范式主要是确保数据表中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单位。</p><h5 id=15-第二范式2nd-nf><strong>1.5</strong> <strong>第二范式(2nd NF)</strong><a hidden class=anchor aria-hidden=true href=#15-第二范式2nd-nf>#</a></h5><p>第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。</p><h5 id=16-第三范式3rd-nf><strong>1.6</strong> <strong>第三范式(3rd NF)</strong><a hidden class=anchor aria-hidden=true href=#16-第三范式3rd-nf>#</a></h5><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</strong>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在"A&ndash;>B&ndash;>C"的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能有依赖关系，必须<code>相互独立</code>。</p><h5 id=17-小结>1.7 小结<a hidden class=anchor aria-hidden=true href=#17-小结>#</a></h5><p>关于数据表的设计，有三个范式要遵循。</p><p>（1）第一范式（1NF），确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p><p>（2）第二范式（2NF），确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况向下，非主键部分不应该依赖于部分主键。</p><p>（3）第三范式（3NF），确保每列都和主键<code>直接相关</code>，而不是间接相关</p><p>**范式的优点：**数据的标准化有助于消除数据库中的<code>数据冗余</code>，第三范式（3NF）通常被认为在性能、拓展性和数据完整性方面达到了最好的平衡。</p><p>**范式的缺点：**范式的使用，可能<code>降低查询的效率</code>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要<code>关联多张表</code>，这不但代价昂贵，也可能使一些<code>索引策略无效</code>。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><h4 id=2-反范式化><strong>2.</strong> <strong>反范式化</strong><a hidden class=anchor aria-hidden=true href=#2-反范式化>#</a></h4><h5 id=21-概述><strong>2.1</strong> <strong>概述</strong><a hidden class=anchor aria-hidden=true href=#21-概述>#</a></h5><p><strong>规范化</strong> <strong>vs</strong> <strong>性能</strong></p><ol><li><p>为满足某种商业目标 , 数据库性能比规范化数据库更重要</p></li><li><p>在数据规范化的同时 , 要综合考虑数据库的性能</p></li><li><p>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</p></li><li><p>通过在给定的表中插入计算列，以方便查询</p></li></ol><h5 id=22-反范式的新问题><strong>2.2</strong> <strong>反范式的新问题</strong><a hidden class=anchor aria-hidden=true href=#22-反范式的新问题>#</a></h5><ul><li>存储<code>空间变大</code>了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则<code>数据不一致</code></li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常<code>消耗系统资源</code></li><li>在<code>数据量小</code>的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加<code>复杂</code></li></ul><h5 id=23-反范式的适用场景><strong>2.3</strong> <strong>反范式的适用场景</strong><a hidden class=anchor aria-hidden=true href=#23-反范式的适用场景>#</a></h5><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><p><strong>1.</strong> <strong>增加冗余字段的建议</strong></p><p>1）这个冗余字段<code>不需要经常进行修改</code></p><p>2）这个冗余字段<code>查询的时候不可或缺</code></p><p><strong>2.</strong> <strong>历史快照、历史数据的需要</strong></p><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><h4 id=3-bcnf巴斯范式><strong>3. BCNF(巴斯范式)</strong><a hidden class=anchor aria-hidden=true href=#3-bcnf巴斯范式>#</a></h4><p>主属性（仓库名）对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致异常情况。因此引入BCNF，<strong>它在</strong> <strong>3NF</strong> <strong>的基础上消除了主属性对候选键的部分依赖或者传递依赖关系</strong>。</p><p>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A->Y，Y为主属性，则该关系不属于BCNF。</p><h4 id=4-er模型><strong>4. ER模型</strong><a hidden class=anchor aria-hidden=true href=#4-er模型>#</a></h4><p>ER模型也叫做<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需要和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p><h5 id=41-er-模型包括那些要素>4.1 ER 模型包括那些要素？<a hidden class=anchor aria-hidden=true href=#41-er-模型包括那些要素>#</a></h5><p><strong>ER</strong> <strong>模型中有三个要素，分别是实体、属性和关系</strong>。</p><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用<code>矩形</code>来表示。实体分为两类，分别是<code>强实体</code>和<code>弱实体</code>。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用<code>椭圆形</code>来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用<code>菱形</code>来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h5 id=42-关系的类型><strong>4.2</strong> <strong>关系的类型</strong><a hidden class=anchor aria-hidden=true href=#42-关系的类型>#</a></h5><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</p><p><code>一对一</code>：指实体之间的关系是一一对应的</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体</p><h4 id=5-数据表的设计原则><strong>5.</strong> <strong>数据表的设计原则</strong><a hidden class=anchor aria-hidden=true href=#5-数据表的设计原则>#</a></h4><p>数据表设计的一般原则：&ldquo;三少一多&rdquo;</p><p><strong>1.</strong> <strong>数据表的个数越少越好</strong></p><p><strong>2.</strong> <strong>数据表中的字段个数越少越好</strong></p><p><strong>3.</strong> <strong>数据表中联合主键的字段个数越少越好</strong></p><p><strong>4.</strong> <strong>使用主键和外键越多越好</strong></p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h4 id=6-数据库对象编写建议><strong>6.</strong> <strong>数据库对象编写建议</strong><a hidden class=anchor aria-hidden=true href=#6-数据库对象编写建议>#</a></h4><h5 id=61-关于库><strong>6.1</strong> <strong>关于库</strong><a hidden class=anchor aria-hidden=true href=#61-关于库>#</a></h5><ol><li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文<code>一律小写</code>，不同单词采用<code>下划线</code>分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建数据库时必须<code>显式指定字符集</code>，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund <code>DEFAULT CHARACTER SET 'utf8'</code>;</p></li><li><p>【建议】对于程序连接数据库账号，遵循<code>权限最小原则</code>。使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号<code>原则上不准有drop权限</code>。</p></li><li><p>【建议】临时库以<code>tmp_</code>为前缀，并以日期为后缀；备份库以<code>bak_</code>为前缀，并以日期为后缀。</p></li></ol><h5 id=62-关于表列><strong>6.2</strong> <strong>关于表、列</strong><a hidden class=anchor aria-hidden=true href=#62-关于表列>#</a></h5><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以<code>英文字母开头</code>。</p></li><li><p>【强制】 <code>表名、列名一律小写</code>，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用<code>统一前缀</code>。比如：crm_fund_item</p></li><li><p>【强制】创建表时必须<code>显式指定字符集</code>为utf8或utf8mb4。</p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须<code>显式指定表存储引擎</code>类型。如无特殊需求，一律为InnoDB。</p></li><li><p>【强制】建表必须有comment。</p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或<code>缩写</code>。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为<code>is_描述</code>。如member表上表示是否为enabled的会员的字段命名为 is_enabled。</p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：<code>表必须有主键 </code>(1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的<code>创建时间字段</code>（create_time）和<code>最后更新时间字段</code>（update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT值</code>。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的<code>列名和列类型必须一致</code>（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称以<code>bak_</code>开头。中间表和备份表定期清理。</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> <span style=color:#a6e22e>user_info</span> ( 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>id<span style=color:#f92672>`</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>AUTO_INCREMENT</span> COMMENT <span style=color:#e6db74>&#39;自增主键&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>user_id<span style=color:#f92672>`</span> <span style=color:#66d9ef>bigint</span>(<span style=color:#ae81ff>11</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;用户id&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>username<span style=color:#f92672>`</span> <span style=color:#66d9ef>varchar</span>(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;真实姓名&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>email<span style=color:#f92672>`</span> <span style=color:#66d9ef>varchar</span>(<span style=color:#ae81ff>30</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;用户邮箱&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>nickname<span style=color:#f92672>`</span> <span style=color:#66d9ef>varchar</span>(<span style=color:#ae81ff>45</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;昵称&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>birthday<span style=color:#f92672>`</span> <span style=color:#66d9ef>date</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;生日&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>sex<span style=color:#f92672>`</span> <span style=color:#66d9ef>tinyint</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#e6db74>&#39;0&#39;</span> COMMENT <span style=color:#e6db74>&#39;性别&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>short_introduce<span style=color:#f92672>`</span> <span style=color:#66d9ef>varchar</span>(<span style=color:#ae81ff>150</span>) <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;一句话介绍自己，最多50个汉字&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>user_resume<span style=color:#f92672>`</span> <span style=color:#66d9ef>varchar</span>(<span style=color:#ae81ff>300</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;用户提交的简历存放地址&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>user_register_ip<span style=color:#f92672>`</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;用户注册时的源ip&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>create_time<span style=color:#f92672>`</span> <span style=color:#66d9ef>timestamp</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CURRENT_TIMESTAMP</span> COMMENT <span style=color:#e6db74>&#39;创建时间&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>update_time<span style=color:#f92672>`</span> <span style=color:#66d9ef>timestamp</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CURRENT_TIMESTAMP</span> <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>UPDATE</span> <span style=color:#66d9ef>CURRENT_TIMESTAMP</span> COMMENT <span style=color:#e6db74>&#39;修改时间&#39;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>`</span>user_review_status<span style=color:#f92672>`</span> <span style=color:#66d9ef>tinyint</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> COMMENT <span style=color:#e6db74>&#39;用户资料审核状态，1为通过，2为审核中，3为未 通过，4为还未提交审核&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (<span style=color:#f92672>`</span>id<span style=color:#f92672>`</span>), 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>uniq_user_id<span style=color:#f92672>`</span> (<span style=color:#f92672>`</span>user_id<span style=color:#f92672>`</span>), 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>idx_username<span style=color:#f92672>`</span>(<span style=color:#f92672>`</span>username<span style=color:#f92672>`</span>), 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>KEY</span> <span style=color:#f92672>`</span>idx_create_time_status<span style=color:#f92672>`</span>(<span style=color:#f92672>`</span>create_time<span style=color:#f92672>`</span>,<span style=color:#f92672>`</span>user_review_status<span style=color:#f92672>`</span>) 
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>ENGINE</span><span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> <span style=color:#66d9ef>CHARSET</span><span style=color:#f92672>=</span>utf8 COMMENT<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;网站用户基本信息&#39;</span>
</span></span></code></pre></div><ol start=17><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</li></ol><h5 id=63-关于索引><strong>6.3</strong> <strong>关于索引</strong><a hidden class=anchor aria-hidden=true href=#63-关于索引>#</a></h5><ol><li><p>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值<code>禁止被更新</code>。</p></li><li><p>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>。</p></li><li><p>【建议】主键的名称以<code>pk_</code>开头，唯一键以<code>uni_</code>或<code>uk_</code>开头，普通索引以<code>idx_</code>开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</p></li><li><p>【建议】单个表上的索引个数<code>不能超过6个</code>。</p></li><li><p>【建议】在建立索引时，多考虑建立<code>联合索引</code>，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在<code>冗余索引</code>。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</p></li></ol><h5 id=64-sql编写><strong>6.4 SQL编写</strong><a hidden class=anchor aria-hidden=true href=#64-sql编写>#</a></h5><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生<code>表锁</code>，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p></li><li><p>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiayi26.github.io/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=https://jiayi26.github.io/posts/%E7%AC%AC19%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/><span class=title>« Prev Page</span><br><span>数据库备份与恢复</span></a>
<a class=next href=https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/><span class=title>Next Page »</span><br><span>用户与权限管理</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f&hashtags=MySQL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f&title=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83&summary=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83&source=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f&title=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83%20-%20https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 数据库的设计规范 on telegram" href="https://telegram.me/share/url?text=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC11%25E7%25AB%25A0-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E7%259A%2584%25E8%25AE%25BE%25E8%25AE%25A1%25E8%25A7%2584%25E8%258C%2583%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>