<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>索引优化与查询优化 | JIAYI's Blog</title><meta name=keywords content="MySQL"><meta name=description content="第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。
 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。
1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。
1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）
 1.7 不等于(!= 或者<>)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&rsquo;')
拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描
 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。
1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。
2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现
结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表
结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表
 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="索引优化与查询优化"><meta property="og:description" content="第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。
 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。
1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。
1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）
 1.7 不等于(!= 或者<>)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&rsquo;')
拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描
 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。
1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。
2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现
结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表
结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表
 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。"><meta property="og:type" content="article"><meta property="og:url" content="https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"><meta property="article:section" content="posts"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="索引优化与查询优化"><meta name=twitter:description content="第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。
 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。
1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。
1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）
 1.7 不等于(!= 或者<>)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&rsquo;')
拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描
 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》
【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。
1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。
2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现
结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表
结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表
 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiayi26.github.io/posts/"},{"@type":"ListItem","position":2,"name":"索引优化与查询优化","item":"https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"索引优化与查询优化","name":"索引优化与查询优化","description":"第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。\n 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。\n其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。\n1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。\n1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。\n1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）\n 1.7 不等于(!= 或者\u0026lt;\u0026gt;)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(\u0026rsquo;')\n拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描\n 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》\n【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。\n1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。\n2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现\n结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表\n结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表\n 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。","keywords":["MySQL"],"articleBody":"第10章 索引优化与查询优化 1. 索引失效案例 MySQL中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。\n 使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。 如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。  大多数情况下都（默认）采用B+树来构建索引。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。\n其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于cost开销(CostBaseOptimizer)，它不是基于规则(Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。\n1.1 全值匹配我最爱 1.2 最佳左前缀法则 在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。\n结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。\n1.3 主键插入顺序 对于一个使用InnoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽小忽大的话，则可能会造成页面分裂和记录移位。\n1.4 计算、函数、类型转换(自动或手动)导致索引失效 1.5 类型转换导致索引失效 1.6 范围条件右边的列索引失效  应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）\n 1.7 不等于(!= 或者)索引失效 1.8 is null可以使用索引，is not null无法使用索引  结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(’')\n拓展：同理，在查询中使用not like也无法使用索引，导致全表扫描\n 1.9 like以通配符%开头索引失效  拓展：Alibaba《Java开发手册》\n【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n 1.10 OR 前后存在非索引的列，索引失效 在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，OR前后的两个条件中的列都是索引时，查询中才使用索引。\n1.11 数据库和表的字符集统一使用utf8mb4 统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。\n2. 关联查询优化  结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现\n结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表\n结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。小表驱动大表\n 2.1 Index Nested-Loop Join（索引嵌套循环连接） Index Nested-Loop Join其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。\n2.2 Block Nested-Loop Join（块嵌套循环连接） 如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。\n不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。\n2.3 Hash Join 从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join\n Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。 Hash Join是做大数据集连接时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立散列值，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。  这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。 它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。    3. 子查询优化 子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL **语句实现比较复杂的查询。但是，子查询的执行效率不高。**原因：\n① 执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和IO资源，产生大量的慢查询。\n② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。\n③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。\n**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。\n 结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代\n 4. 排序优化   SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 避免全表扫描，在 ORDER BY 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。\n  尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。\n  无法使用 Index 时，需要对 FileSort 方式进行调优。\n  5. GROUP BY优化  group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。 group by 先排序再分组，遵照索引建的最佳左前缀法则 当无法使用索引列，可以增大max_length_for_sort_data和sort_buffer_size参数的设置 where效率高于having，能写在where限定的条件就不要写在having中了 减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。  6. 优化分页查询 优化思路一\n在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。\nEXPLAIN SELECT * FROM student t,(SELECT id FROM student ORDER BY id LIMIT 2000000,10) a WHERE t.id = a.id; 优化思路二\n该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。\nEXPLAIN SELECT * FROM student WHERE id  2000000 LIMIT 10; 7. 优先考虑覆盖索引 7.1 什么是覆盖索引？ 理解方式一：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。\n理解方式二：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。\n简单说就是，索引列+主键包含SELECT 到 FROM之间查询的列。\n7.2 覆盖索引的利弊 好处：\n1. 避免Innodb表进行索引的二次查询（回表）\n2. 可以把随机IO变成顺序IO加快查询效率\n弊端：\n索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。\n8. 索引条件下推 8.1 使用前后的扫描过程 在不使用ICP索引扫描的过程：\nstorage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层\nserver 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。\n使用ICP扫描的过程：\nstorage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。\nserver 层：对返回的数据，使用table filter条件做最后的过滤。\n9. 其它查询优化策略 9.1 EXISTS 和 IN 的区分 索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为小表驱动大表。\n9.2 COUNT(*)与COUNT(具体字段)效率 环节1：COUNT(*)和COUNT(1)都是对所有结果进行COUNT，COUNT(*)和COUNT(1)本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。\n**环节2：**如果是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count值，而一致性则是由表级锁来保证的。\n如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，是O(n)的复杂度，进行循环+计数的方式来完成统计。\n**环节3：**在InnoDB引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。\n如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。\n9.3 关于SELECT(*) 在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT  查询。原因：\n① MySQL 在解析的过程中，会通过查询数据字典将\"*“按序转换成所有列名，这会大大的耗费资源和时间。\n② 无法使用覆盖索引\n9.4 LIMIT 1 对优化的影响 针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。\n如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。\n9.5 多使用COMMIT 只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。\nCOMMIT 所释放的资源：\n  回滚段上用于恢复数据的信息\n  被程序语句获得的锁\n  redo / undo log buffer 中的空间\n  管理上述 3 种资源中的内部花费\n   ","wordCount":"304","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiayi26.github.io/posts/%E7%AC%AC10%E7%AB%A0-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"},"publisher":{"@type":"Organization","name":"JIAYI's Blog","logo":{"@type":"ImageObject","url":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiayi26.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://jiayi26.github.io/posts/>Posts</a></div><h1 class=post-title>索引优化与查询优化</h1><div class=post-meta>2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/Pass-JIAYI%27s.github.io/post/posts/%e7%ac%ac10%e7%ab%a0%20%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=第10章-索引优化与查询优化>第10章 索引优化与查询优化<a hidden class=anchor aria-hidden=true href=#第10章-索引优化与查询优化>#</a></h3><h4 id=1-索引失效案例><strong>1.</strong> <strong>索引失效案例</strong><a hidden class=anchor aria-hidden=true href=#1-索引失效案例>#</a></h4><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了访问高效数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-树</code>，并且MEMORY表还支持<code>hash索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销(CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-BasedOptimizer)</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<strong>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</strong></p><h5 id=11-全值匹配我最爱><strong>1.1</strong> <strong>全值匹配我最爱</strong><a hidden class=anchor aria-hidden=true href=#11-全值匹配我最爱>#</a></h5><h5 id=12-最佳左前缀法则><strong>1.2</strong> <strong>最佳左前缀法则</strong><a hidden class=anchor aria-hidden=true href=#12-最佳左前缀法则>#</a></h5><p>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于多列索引，**过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。**如果查询条件中没有使用这些字段中第1个字段时，多列（或联合）索引不会被使用。</p><h5 id=13-主键插入顺序><strong>1.3</strong> <strong>主键插入顺序</strong><a hidden class=anchor aria-hidden=true href=#13-主键插入顺序>#</a></h5><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序，所以如果我们<code>插入</code>的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的<code>主键值忽小忽大</code>的话，则可能会造成<code>页面分裂</code>和<code>记录移位</code>。</p><h5 id=14-计算函数类型转换自动或手动导致索引失效><strong>1.4</strong> <strong>计算、函数、类型转换(自动或手动)导致索引失效</strong><a hidden class=anchor aria-hidden=true href=#14-计算函数类型转换自动或手动导致索引失效>#</a></h5><h5 id=15-类型转换导致索引失效><strong>1.5</strong> <strong>类型转换导致索引失效</strong><a hidden class=anchor aria-hidden=true href=#15-类型转换导致索引失效>#</a></h5><h5 id=16-范围条件右边的列索引失效><strong>1.6</strong> <strong>范围条件右边的列索引失效</strong><a hidden class=anchor aria-hidden=true href=#16-范围条件右边的列索引失效>#</a></h5><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置where语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><h5 id=17-不等于-或者索引失效><strong>1.7</strong> <strong>不等于(!= 或者&lt;>)索引失效</strong><a hidden class=anchor aria-hidden=true href=#17-不等于-或者索引失效>#</a></h5><h5 id=18-is-null可以使用索引is-not-null无法使用索引><strong>1.8 is null可以使用索引，is not null无法使用索引</strong><a hidden class=anchor aria-hidden=true href=#18-is-null可以使用索引is-not-null无法使用索引>#</a></h5><blockquote><p>结论：最好在设计数据表的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(&rsquo;')</p><p>拓展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描</p></blockquote><h5 id=19-like以通配符开头索引失效><strong>1.9 like以通配符%开头索引失效</strong><a hidden class=anchor aria-hidden=true href=#19-like以通配符开头索引失效>#</a></h5><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h5 id=110-or-前后存在非索引的列索引失效><strong>1.10 OR</strong> <strong>前后存在非索引的列，索引失效</strong><a hidden class=anchor aria-hidden=true href=#110-or-前后存在非索引的列索引失效>#</a></h5><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><h5 id=111-数据库和表的字符集统一使用utf8mb4><strong>1.11</strong> <strong>数据库和表的字符集统一使用utf8mb4</strong><a hidden class=anchor aria-hidden=true href=#111-数据库和表的字符集统一使用utf8mb4>#</a></h5><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p><h4 id=2-关联查询优化><strong>2.</strong> <strong>关联查询优化</strong><a hidden class=anchor aria-hidden=true href=#2-关联查询优化>#</a></h4><blockquote><p>结论1：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表出现</p><p>结论2：对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表</p><p>结论3：对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></p></blockquote><h5 id=21-index-nested-loop-join索引嵌套循环连接>2.1 Index Nested-Loop Join（索引嵌套循环连接）<a hidden class=anchor aria-hidden=true href=#21-index-nested-loop-join索引嵌套循环连接>#</a></h5><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内层表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011826671.png alt=image-20220401182649509></p><h5 id=22-block-nested-loop-join块嵌套循环连接>2.2 Block Nested-Loop Join（块嵌套循环连接）<a hidden class=anchor aria-hidden=true href=#22-block-nested-loop-join块嵌套循环连接>#</a></h5><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/aoshihuankong/cloudimg@master/img/202204011833000.png alt=image-20220401183344880></p><h5 id=23-hash-join>2.3 Hash Join<a hidden class=anchor aria-hidden=true href=#23-hash-join>#</a></h5><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li>Nested Loop：对于被连接的数据子集较小的情况下，Nested Loop是个较好的选择。</li><li>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列值</code>，然后扫描较大的表并探测散列值，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放入内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join只能应用于等值连接，这是由Hash的特点决定的。</li></ul></li></ul><h4 id=3-子查询优化><strong>3.</strong> <strong>子查询优化</strong><a hidden class=anchor aria-hidden=true href=#3-子查询优化>#</a></h4><p><strong>子查询是</strong> <strong>MySQL</strong> <strong>的一项重要的功能，可以帮助我们通过一个</strong> <strong>SQL</strong> **语句实现比较复杂的查询。但是，子查询的执行效率不高。**原因：</p><p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><p>**在MySQL中，可以使用连接（JOIN）查询来替代子查询。**连接查询<code>不需要建立临时表</code>，其<code>速度比子查询要快</code>，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><h4 id=4-排序优化><strong>4.</strong> <strong>排序优化</strong><a hidden class=anchor aria-hidden=true href=#4-排序优化>#</a></h4><ol><li><p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中 <code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p></li><li><p>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</p></li><li><p>无法使用 Index 时，需要对 FileSort 方式进行调优。</p></li></ol><h4 id=5-group-by优化><strong>5. GROUP BY优化</strong><a hidden class=anchor aria-hidden=true href=#5-group-by优化>#</a></h4><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，可以增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ul><h4 id=6-优化分页查询><strong>6.</strong> <strong>优化分页查询</strong><a hidden class=anchor aria-hidden=true href=#6-优化分页查询>#</a></h4><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student t,(<span style=color:#66d9ef>SELECT</span> id <span style=color:#66d9ef>FROM</span> student <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> id <span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>2000000</span>,<span style=color:#ae81ff>10</span>) a
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> t.id <span style=color:#f92672>=</span> a.id;
</span></span></code></pre></div><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#66d9ef>EXPLAIN</span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> student <span style=color:#66d9ef>WHERE</span> id <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>2000000</span> <span style=color:#66d9ef>LIMIT</span> <span style=color:#ae81ff>10</span>;
</span></span></code></pre></div><h4 id=7-优先考虑覆盖索引><strong>7.</strong> <strong>优先考虑覆盖索引</strong><a hidden class=anchor aria-hidden=true href=#7-优先考虑覆盖索引>#</a></h4><h5 id=71-什么是覆盖索引><strong>7.1</strong> <strong>什么是覆盖索引？</strong><a hidden class=anchor aria-hidden=true href=#71-什么是覆盖索引>#</a></h5><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><h5 id=72-覆盖索引的利弊><strong>7.2</strong> <strong>覆盖索引的利弊</strong><a hidden class=anchor aria-hidden=true href=#72-覆盖索引的利弊>#</a></h5><p><strong>好处：</strong></p><p><strong>1.</strong> <strong>避免Innodb表进行索引的二次查询（回表）</strong></p><p><strong>2.</strong> <strong>可以把随机IO变成顺序IO加快查询效率</strong></p><p><strong>弊端：</strong></p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><h4 id=8-索引条件下推><strong>8.</strong> <strong>索引条件下推</strong><a hidden class=anchor aria-hidden=true href=#8-索引条件下推>#</a></h4><h5 id=81-使用前后的扫描过程><strong>8.1</strong> <strong>使用前后的扫描过程</strong><a hidden class=anchor aria-hidden=true href=#81-使用前后的扫描过程>#</a></h5><p><strong>在不使用ICP索引扫描的过程：</strong></p><p>storage层：只将满足index key条件的索引记录对应的整行记录取出，返回给server层</p><p>server 层：对返回的数据，使用后面的where条件过滤，直至返回最后一行。</p><p><strong>使用ICP扫描的过程：</strong></p><p>storage层：首先将index key条件满足的索引记录区间确定，然后在索引上使用index filter进行过滤。将满足的index filter条件的索引记录才去回表取出整行记录返回server层。不满足index filter条件的索引记录丢弃，不回表、也不会返回server层。</p><p>server 层：对返回的数据，使用table filter条件做最后的过滤。</p><h4 id=9-其它查询优化策略><strong>9.</strong> <strong>其它查询优化策略</strong><a hidden class=anchor aria-hidden=true href=#9-其它查询优化策略>#</a></h4><h5 id=91-exists-和-in-的区分><strong>9.1 EXISTS</strong> <strong>和</strong> <strong>IN</strong> <strong>的区分</strong><a hidden class=anchor aria-hidden=true href=#91-exists-和-in-的区分>#</a></h5><p>索引是个前提，其实选择与否还会要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。</p><h5 id=92-count与count具体字段效率><strong>9.2 COUNT(*)与COUNT(具体字段)效率</strong><a hidden class=anchor aria-hidden=true href=#92-count与count具体字段效率>#</a></h5><p><strong>环节1：</strong><code>COUNT(*)</code>和<code>COUNT(1)</code>都是对所有结果进行<code>COUNT</code>，<code>COUNT(*)</code>和<code>COUNT(1)</code>本质上并没有区别（二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的）。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计；如果没有WHERE子句，则是对数据表的数据行数进行统计。</p><p>**环节2：**如果是MyISAM存储引擎，统计数据表的行数只需要<code>O(1)</code>的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则是由表级锁来保证的。</p><p>如果是InnoDB存储引擎，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用<code>扫描全表</code>，是<code>O(n)</code>的复杂度，进行循环+计数的方式来完成统计。</p><p>**环节3：**在InnoDB引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，系统会<code>自动</code>采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h5 id=93-关于select><strong>9.3</strong> <strong>关于SELECT(*)</strong><a hidden class=anchor aria-hidden=true href=#93-关于select>#</a></h5><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表> 查询。原因：</p><p>① MySQL 在解析的过程中，会通过<code>查询数据字典</code>将"*&ldquo;按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用<code>覆盖索引</code></p><h5 id=94-limit-1-对优化的影响><strong>9.4 LIMIT 1</strong> <strong>对优化的影响</strong><a hidden class=anchor aria-hidden=true href=#94-limit-1-对优化的影响>#</a></h5><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上<code>LIMIT 1</code>了。</p><h5 id=95-多使用commit><strong>9.5</strong> <strong>多使用COMMIT</strong><a hidden class=anchor aria-hidden=true href=#95-多使用commit>#</a></h5><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li><p>回滚段上用于恢复数据的信息</p></li><li><p>被程序语句获得的锁</p></li><li><p>redo / undo log buffer 中的空间</p></li><li><p>管理上述 3 种资源中的内部花费</p></li></ul><h3 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiayi26.github.io/tags/mysql/>MySQL</a></li></ul><nav class=paginav><a class=prev href=https://jiayi26.github.io/posts/%E7%AC%AC03%E7%AB%A0-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/><span class=title>« Prev Page</span><br><span>用户与权限管理</span></a>
<a class=next href=https://jiayi26.github.io/posts/%E7%AC%AC08%E7%AB%A0-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/><span class=title>Next Page »</span><br><span>索引的创建与设计原则</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f&hashtags=MySQL"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f&title=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96&summary=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96&source=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f&title=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%20-%20https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 索引优化与查询优化 on telegram" href="https://telegram.me/share/url?text=%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e4%b8%8e%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96&url=https%3a%2f%2fjiayi26.github.io%2fposts%2f%25E7%25AC%25AC10%25E7%25AB%25A0-%25E7%25B4%25A2%25E5%25BC%2595%25E4%25BC%2598%25E5%258C%2596%25E4%25B8%258E%25E6%259F%25A5%25E8%25AF%25A2%25E4%25BC%2598%25E5%258C%2596%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>