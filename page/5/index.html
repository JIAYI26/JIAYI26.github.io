<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.97.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JIAYI's Blog</title><meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="JIAYI's Blog"><meta name=author content="Me"><link rel=canonical href=https://jiayi26.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><link rel=icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=16x16 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=icon type=image/png sizes=32x32 href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=apple-touch-icon href=https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3><link rel=mask-icon href=https://jiayi26.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://jiayi26.github.io/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="JIAYI's Blog"><meta property="og:description" content="JIAYI's Blog"><meta property="og:type" content="website"><meta property="og:url" content="https://jiayi26.github.io/"><meta property="og:site_name" content="JIAYI's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="JIAYI's Blog"><meta name=twitter:description content="JIAYI's Blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"JIAYI's Blog","url":"https://jiayi26.github.io/","description":"JIAYI\u0026#39;s Blog","thumbnailUrl":"https://xx.mzqcgc.cn/FrbOmxJvq96XDbDPXbiBWM0LU9e3","sameAs":["https://twitter.com/","https://stackoverflow.com","https://github.com/JIAYI26"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiayi26.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jiayi26.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jiayi26.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>TCP三次握手和四次挥手</h2></header><div class=entry-content><p>TCP三次握手 (1)第一次握手：客户端发送连接请求报文，SYN=1，seq=x，进入 SYN_SENT 状态，等待服务器确认 (2)第二次握手：服务器收到请求报文，确认请求报文后发送 SYN+ack 包，SYN=1，ack=x+1，seq=y，进入 SYN_RECV 状态 (3)第三次握手：客户端收到服务器的 SYN+ack 包，向服务器发送 ack 包 SYN=1，ack=y+1，seq=x+1，进入ESTABLISHED状态
序列号(Sequence Number)：发送数据包中的第一个字节的序列号，保证网络传输数据的有序性 确认应答号(Acknowledgement Number)：表示已经收到数据包，用来解决网络中丢包的问题 ACK：为1时，确认应答号有效 SYN：为1时，发起一个连接（在建立TCP连接的时候使用） FIN：为1时，关闭一个连接（在关闭TCP连接的时候使用）
TCP四次挥手 (1)第一次挥手：客户端进程发出连接释放报文，FIN=1，seq=u，客户端进入 FIN-WAIT-1（终止等待1）状态 (2)第二次挥手：服务器收到连接释放报文，发出确认报文 ack=u+1，seq=v，进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间 (3)第三次挥手：客户端收到服务器的确认请求后，客户端就进入FIN-WAIT-2（终止等待2）状态。等待服务器发送连接释放报文。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，seq=w，进入了LAST-ACK（最后确认）状态。 (4)第四次挥手：客户端收到服务器的连接释放报文后，发出确认报文 ack=w+1，seq=u+1，客户端就进入了TIME-WAIT（时间等待）状态。此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间，才进入CLOSED状态
为什么连接的时候是三次握手，关闭的时候却是四次握手？ 当客户端发出FIN报文时，只是表示Client已经没有数据要发送了，这个时候Client还是可以接受来自Server的数据。当Server收到FIN报文时，会先回复一个ACK报文，告诉Client，“你发的FIN报文我收到了”。只有等Server所有的报文都发送完，才会发送FIN报文。
为什么要等待2MSL？ 为了保证Client发送的最后一个ACK报文段能够到达Server Client发送的ACK报文可能丢失，Server如果没有收到ACK，将不断重复发送FIN报文。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK报文并再次等待2MSL
MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。
防止已经失效的连接请求报文段出现在新连接中 Client在发送完最后一个ACK报文段后，再经过时间2MSL。就可以使本连接持续的时间内所产生的所有报文段都在网络中消失。这样就可以在下一个新的连接中不会出现这种旧的连接请求报文段。</p></div><footer class=entry-footer><span title="2022-10-28 21:33:57 +0800 CST">October 28, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP三次握手和四次挥手" href=https://jiayi26.github.io/posts/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/></a></article><article class=post-entry><header class=entry-header><h2>Kubernetes概念</h2></header><div class=entry-content><p>Kubernetes是什么？ Kubernetes 是一个生产级别的容器编排平台和集群管理系统。用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。
传统部署时代 早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程式资源利用率不高时，剩余资源无法被分配给其他应用程式， 而且维护许多物理服务器的成本很高。
虚拟化部署时代 因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。
虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。
每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
容器部署时代 容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。
容器因具有许多优势而变得流行起来，例如：
敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。 关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。 Kubernetes能做什么？ 容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？...</p></div><footer class=entry-footer><span title="2022-08-16 22:23:48 +0800 CST">August 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes概念" href=https://jiayi26.github.io/posts/kubernetes%E6%A6%82%E5%BF%B5/></a></article><article class=post-entry><header class=entry-header><h2>Kubernetes环境搭建</h2></header><div class=entry-content><p>minikube 下载安装minikube Intel x86_64 curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube Apple arm64 curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64 sudo install minikube /usr/local/bin/ 安装完成之后，你可以执行命令 minikube version，看看它的版本号，验证是否安装成功：
[root@localhost ~]# minikube version minikube version: v1.28.0 安装kubectl minikube kubectl 验证 minikube 环境 前面的工作都做完之后，我们就可以在本机上运行 minikube，创建 Kubernetes 实验环境了。 使用命令 minikube start 会从 Docker Hub 上拉取镜像，以当前最新版本的 Kubernetes 启动集群。不过为了保证实验环境的一致性，我们可以在后面再加上一个参数 –kubernetes-version，明确指定要使用 Kubernetes 版本。 这里我使用“1.23.3”，启动命令就是（启动 k8s 集群使用root用户时，要加上–force命令，使用国内镜像，要加上–image-mirror-country=‘cn’）：
minikube start --kubernetes-version=v1.23.3 --force --image-mirror-country='cn' 现在 Kubernetes 集群就已经在我们本地运行了，你可以使用 minikube status、minikube node list这两个命令来查看集群的状态：
minikube status minikube node list 有了集群，接下来我们就可以使用 kubectl 来操作一下，初步体会 Kubernetes 这个容器编排系统，最简单的命令当然就是查看版本：...</p></div><footer class=entry-footer><span title="2022-08-16 22:23:09 +0800 CST">August 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes环境搭建" href=https://jiayi26.github.io/posts/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/></a></article><article class=post-entry><header class=entry-header><h2>Kubernetes组件</h2></header><div class=entry-content><p>Kubernetes 的基本架构 Kubernetes 采用了现今流行的“控制面 / 数据面”（Control Plane / Data Plane）架构，集群里的计算机被称为“节点”（Node），可以是实机也可以是虚机，少量的节点用作控制面来执行集群的管理维护工作，其他的大部分节点都被划归数据面，用来跑业务应用。
控制面的节点在 Kubernetes 里叫做 Master Node，一般简称为 Master，它是整个集群里最重要的部分，可以说是 Kubernetes 的大脑和心脏。
数据面的节点叫做 Worker Node，一般就简称为 Worker 或者 Node，相当于 Kubernetes 的手和脚，在 Master 的指挥下干活。
Node 的数量非常多，构成了一个资源池，Kubernetes 就在这个池里分配资源，调度应用。因为资源被“池化”了，所以管理也就变得比较简单，可以在集群中任意添加或者删除节点。 Master组件 Master组件为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 replicas 字段时， 要启动新的 pod）。
控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。
apiserver 是整个 Kubernetes 系统的唯一入口，它对外公开了一系列的 RESTful API，并且加上了验证、授权等功能，所有其他组件都只能和它直接通信，可以说是 Kubernetes 里的联络员。
etcd 是一个高可用的分布式 Key-Value 数据库，用来持久化存储系统里的各种资源对象和状态，相当于 Kubernetes 里的配置管理员。注意它只与 apiserver 有直接联系，也就是说任何其他组件想要读写 etcd 里的数据都必须经过 apiserver。
scheduler 负责容器的编排工作，检查节点的资源状态，把 Pod 调度到最适合的节点上运行，相当于部署人员。因为节点状态和 Pod 信息都存储在 etcd 里，所以 scheduler 必须通过 apiserver 才能获得。...</p></div><footer class=entry-footer><span title="2022-08-16 22:23:09 +0800 CST">August 16, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes组件" href=https://jiayi26.github.io/posts/kubernetes%E7%BB%84%E4%BB%B6/></a></article><article class=post-entry><header class=entry-header><h2>Docker</h2></header><div class=entry-content><p>Docker的概述 什么是Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux或Windows操作系统的机器上。 Docker 是基于 Go 语言实现，遵从apache 2.0协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障。 Docker 是基于 linux 内核实现的，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器。 Docker的主要目标 “Build，Ship and Run Any App,Anywhere”，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了“它可以在我的笔记本电脑上运行！” 问题。
Docker的组成 镜像(Images)：镜像可以理解为创建实例使用的模板 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/ 容器和虚拟机的比较 容器和虚拟机具有相似的资源隔离和分配优势，但功能不同，因为容器虚拟化的是操作系统而不是硬件。容器更便携、更高效。
容器是应用层的抽象，它将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。与 VM 相比，容器占用的空间更少（容器映像的大小通常为数十 MB），可以处理更多应用程序并且需要更少的 VM 和操作系统。
虚拟机 (VM) 是物理硬件的抽象，可将一台服务器变成多台服务器。管理程序允许多个虚拟机在单台机器上运行。每个 VM 都包含操作系统、应用程序、必要的二进制文件和库的完整副本——占用数十 GB。VM 的启动速度也比较慢。
资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机 开销更小：不需要启动单独的虚拟机OS内核占用硬件资源 启动速度更快：可以在数秒内完成启动 集成性更好：和CI/CD（持续集成/持续部署）相关技术结合性更好，实现自动化管理 Docker的安装 官方文档：https://docs.docker.com/engine/install/centos/ 这里以CentOS7为例
卸载旧版本 [root@test_server ~]# yum remove docker \ > docker-client \ > docker-client-latest \ > docker-common \ > docker-latest \ > docker-latest-logrotate \ > docker-logrotate \ > docker-engine 设置镜像仓库 由于官网的yum源太慢，下面把镜像仓库设置成阿里云的...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Docker" href=https://jiayi26.github.io/posts/docker/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://jiayi26.github.io/page/4/>« Prev Page</a>
<a class=next href=https://jiayi26.github.io/page/6/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://jiayi26.github.io/>JIAYI's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>